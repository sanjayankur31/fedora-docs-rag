= Welcome

Welcome to Fedora Internet of Things homepage. Fedora Internet of Things is a Fedora Edition to provide a strong foundation for IoT ecosystems. Whether you're working on a project at home, industrial gateways, smart cities or analytics with AI/ML, Fedora IoT can provide a trusted open source platform to build on. Fedora IoT rolling releases help you keep your ecosystem up-to-date.

== Why use Fedora IoT?
The operating system (OS) for IoT systems needs to be immutable and image based, where the image is fully tested centrally and signed before being deployed at scale to IoT systems. As these IoT systems are often located remotely, the OS should support atomic updates so nothing changes until the device is rebooted and rollback capability so it is easy to recover remotely if there is a failure during upgrade.

The Fedora IoT images work with https://coreos.github.io/rpm-ostree/[rpm-ostree], a hybrid image/package system. It supports package layering, which allows installation of RPMs for additional hardware support or applications. The GPG signed image based deployments scale well to very large numbers of clients. Updates are atomic with easy rollback capability.

The Fedora IoT images also have excellent support for container-focused workflows. Containers allow you to separate core OS updates from application updates as well as test and deploy different versions of applications.  The https://podman.io/[podman] container engine is light weight and ready for you to download or create containers for your home assistant, industrial gateways, or data storage and analytics.

== Is Fedora IoT for you?

If you are looking for a graphical desktop environment based on OSTree and designed for developers, look at https://fedoraproject.org/atomic-desktops/silverblue/[Fedora Silverblue].

If you are looking for a traditional dnf based operating system for your device, visit https://fedoraproject.org/[Fedora].

If you are after an OS for Kubernetes, there is https://fedoraproject.org/en/coreos/[Fedora CoreOS].

If you are looking for a lightweight yet powerful and scalable core OS for your Internet of Things project, you came to the right place! xref:getting-started.adoc[Get Started with Fedora IoT]!

== Contribute to Fedora IoT Edition
For communication and contributing please see the xref:contributing.adoc[Contributing and Reporting Bugs] section.

image::iot-fedora.svg[SoC board]


= Getting Started


Welcome to the getting started guide for Fedora IoT.
Both this guide and Fedora IoT images are in the very early stages, so please report any issues to https://lists.fedoraproject.org/admin/lists/iot.lists.fedoraproject.org/[the mailing list].

image::iot-fedora.svg[SoC board]

== Supported Platforms

Fedora IoT supports the x86_64 and aarch64 architectures.

Refer to the list of currently tested xref:reference-platforms.adoc[Reference Platforms]. The list of supported reference platforms will expand over time.
Other x86_64 or aarch64 platforms should work just fine but haven't been widely tested in the IoT context so your milage may vary.

If you're a hardware vendor and would like to have a device become a reference platform by actively participating and testing Fedora IoT,
please reach out to https://fedoraproject.org/wiki/User:Pbrobinson[Peter Robinson], the Fedora IoT Lead.

== Required Resources
The current images are 4GB in size and tested with 1GB of RAM.
The Fedora IoT base image should be able to run with less resources, but of course this will limit the amount of container applications that can be run on top of the base OS.

== Download Image

Fedora IoT images are available for download at the https://fedoraproject.org/iot/download[Download Fedora IoT page]. There are three options available to install IoT on your device:

\&#42; Anaconda installer ISO (Fedora-IoT-ostree-XX.XX.iso ) - The traditional Fedora installer, offers an interactive graphical installation tool to configure most aspects of the system including filesystem, users and passwords.
\&#42; Disk image (Fedora-IoT-raw-XX.XX.raw.xz) - A pre-built disk image suitable for single board computers (SBC's) like the Raspberry Pi 4.
\&#42; Simplified Provisioning ISO (Fedora-IoT-provisioner-XX.iso) - A new tool offering zero touch installation leveraging xref:fdo-device-setup.adoc[FIDO Device Onboarding] or xref:ignition-device-setup.adoc[Ignition] for configuration.

== Setup VM or Physical Device

- Follow these steps to xref:virtual-machine-setup.adoc[setup virtual machine]

- Follow these steps to xref:physical-device-setup.adoc[setup physical device]


Follow the setup instructions from xref:ignition-device-setup.adoc[ignition]


= Obtaining Images

Available images for download are described on the https://fedoraproject.org/iot/download[Download Fedora IoT page].

== Why the Fedora IoT Image

The use of https://ostree.readthedocs.io/en/latest/[OSTree] brings fully atomic upgrades, easy rollbacks and workflows that are familiar to users of immutable, image based servers.

An OS image that is composed on the server side allows for testing the exact bits before they reach client systems, leading to more reliable updates.
The GPG signed image based deployments scale well to very large numbers of clients.
Updates are atomic so nothing changes until the device is rebooted and the rollback capability makes it easy to recover remotely if there is a failure during upgrade.

The Fedora IoT images work with https://rpm-ostree.readthedocs.io/en/latest/[rpm-ostree] which is a hybrid image/package system.
It supports package layering, which allows installation of RPMs for additional hardware support or applications.

The Fedora IoT images also have excellent support for container-focused workflows.
Containers allow you to separate core OS updates from application updates as well as test and deploy different versions of applications.
The https://podman.io/[podman] daemon is light weight and ready for you to download or create containers for your home assistant, industrial gateways, or data storage and analytics.

== Pick the Right Tool for the Job

If you are looking for a graphical desktop environment based on OSTree and designed for developers, look at https://silverblue.fedoraproject.org/[Fedora Silverblue].

If you are looking for a traditional dnf based operating system for your ARM device, visit https://fedoraproject.org/[Fedora].

If you are looking for a lightweight yet powerful and scalable core OS for your Internet of Things project, you came to the right place! https://fedoraproject.org/iot/download[Download the images now]!


= Building Custom Fedora IoT Images with image-builder

https://github.com/osbuild/image-builder-cli[image-builder] is a command-line tool for building custom operating system images for Fedora, CentOS, and RHEL. This guide explains how to use image-builder to create customized Fedora IoT images with your own package selections, user configurations, and settings.

NOTE: For pre-built Fedora IoT images without customization, see xref:obtaining-images.adoc[Obtaining Images].

== Installing image-builder

To install image-builder on Fedora:

----
$ sudo dnf install image-builder ostree
----

== Available Fedora IoT Image Types

image-builder supports several IoT-specific image types for x86_64 and aarch64 architectures:

\&#42; \&#96;iot-commit\&#96; - OSTree commit tarball (the foundation for custom images)
\&#42; \&#96;iot-installer\&#96; - Anaconda installer ISO for interactive installation
\&#42; \&#96;iot-simplified-installer\&#96; - Zero-touch installer using FDO or Ignition
\&#42; \&#96;iot-raw-xz\&#96; - Compressed raw disk image for physical devices (e.g., Raspberry Pi)
\&#42; \&#96;iot-qcow2\&#96; - QCOW2 disk image for virtual machines
\&#42; \&#96;iot-container\&#96; - OCI container with OSTree commit
\&#42; \&#96;iot-bootable-container\&#96; - Bootable container image

To list all available IoT image types:

----
$ image-builder list | grep iot
----

== Building Custom Fedora IoT Images

The typical workflow for creating custom Fedora IoT images is:

1. Create a blueprint describing your customizations
2. Build a custom OSTree commit with your changes
3. Serve the OSTree commit locally
4. Build installation media or disk images from your custom commit

=== Step 1: Creating a Blueprint

Blueprints are TOML files that describe customizations for your image. They allow you to:

\&#42; Add or remove packages
\&#42; Configure users and groups
\&#42; Set up SSH keys
\&#42; Configure system settings

Create a blueprint file (example: \&#96;iot-custom.toml\&#96;):

----
name = 'iot-custom'
description = 'Custom Fedora IoT Image'
version = '0.0.1'

[[packages]]
name = 'vim-enhanced'

[[packages]]
name = 'htop'

[[packages]]
name = 'tmux'

[[customizations.user]]
name = 'admin'
description = 'Admin User'
password = '$6$rounds=4096$saltsalt$encrypted_password_hash'
groups = ['wheel']

[[customizations.sshkey]]
user = 'admin'
key = 'ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIExample admin@workstation'
----

NOTE: Generate encrypted passwords with \&#96;openssl passwd -6\&#96; (will prompt for password interactively)

=== Step 2: Building a Custom OSTree Commit

Build an OSTree commit tarball with your customizations. Use the official ref naming pattern (\&#96;fedora/stable\&#96;, \&#96;fedora/devel\&#96;, or \&#96;fedora/rawhide\&#96;):

----
$ sudo image-builder build iot-commit \
--distro fedora-43 \
--blueprint iot-custom.toml \
--ostree-ref fedora/stable/x86_64/iot \
--output-dir ./iot-commit-output

\&#35; Note For aarch64 use \&#96;fedora/stable/aarch64/iot\&#96;
----

This creates a tarball containing your customized OSTree commit.

=== Step 3: Setting Up a Local OSTree Repository

Extract the commit tarball and serve the OSTree repository:

----
$ tar -xf ./iot-commit-output/\&#42;.tar
$ mv repo ostree-repo
$ cd ostree-repo
$ python3 -m http.server 8000
----

The tarball contains a \&#96;repo/\&#96; directory with the complete OSTree repository. To run the HTTP server in the background, add \&#96;\&amp;\&#96; at the end:

----
$ python3 -m http.server 8000 \&amp;
----

Your custom OSTree repository is now available at \&#96;http://localhost:8000\&#96;

To verify the repository is properly set up:

----
$ ostree --repo=./ostree-repo refs
$ curl http://localhost:8000/refs/heads/fedora/stable/x86_64/iot
----

== Building Images from Your Custom OSTree

With your custom OSTree commit served locally, you can now build various image types.

=== Building an Installer ISO

Create an Anaconda installer ISO that will install your customized Fedora IoT:

----
$ sudo image-builder build iot-installer \
--distro fedora-43 \
--ostree-url http://localhost:8000 \
--ostree-ref fedora/stable/x86_64/iot \
--output-dir ./images
----

=== Building a Simplified Installer

The simplified installer provides zero-touch provisioning using FDO or Ignition:

----
$ sudo image-builder build iot-simplified-installer \
--distro fedora-43 \
--ostree-url http://localhost:8000 \
--ostree-ref fedora/stable/x86_64/iot \
--output-dir ./images
----

See xref:booting-the-simplified-provisioner.adoc[Booting the Simplified Provisioner] for more details.

=== Building Raw Disk Images

For single-board computers like Raspberry Pi, create a compressed raw disk image:

----
$ sudo image-builder build iot-raw-xz \
--distro fedora-43 \
--arch aarch64 \
--ostree-url http://localhost:8000 \
--ostree-ref fedora/stable/aarch64/iot \
--output-dir ./images
----

These images can be written directly to SD cards or other storage media.

=== Building QCOW2 Images for VMs

For testing in virtual machines:

----
$ sudo image-builder build iot-qcow2 \
--distro fedora-43 \
--ostree-url http://localhost:8000 \
--ostree-ref fedora/stable/x86_64/iot \
--output-dir ./images
----

=== Building Container Images

Create an OCI container with your OSTree commit:

----
$ sudo image-builder build iot-container \
--distro fedora-43 \
--ostree-url http://localhost:8000 \
--ostree-ref fedora/stable/x86_64/iot \
--output-dir ./images
----

Create a bootable container image for modern container-native workflows:

----
$ sudo image-builder build iot-bootable-container \
--distro fedora-43 \
--ostree-url http://localhost:8000 \
--ostree-ref fedora/stable/x86_64/iot \
--output-dir ./images
----

See xref:fedora-iot-bootc.adoc[Fedora IoT Bootc] for more information on bootable containers.

== Serving Your OSTree Repository to Other Machines

To make your custom OSTree repository available to other machines on your network:

----
$ cd ostree-repo
$ python3 -m http.server 8000 --bind 0.0.0.0 \&amp;
----

NOTE: The \&#96;\&amp;\&#96; runs the server in background. To stop it later, use \&#96;pkill -f 'http.server 8000'\&#96;

Then use your machine's IP address when building images on other systems:

----
$ sudo image-builder build iot-installer \
--distro fedora-43 \
--ostree-url http://192.168.1.100:8000 \
--ostree-ref fedora/stable/x86_64/iot \
--output-dir ./images
----

== Advanced Options

=== Adding Extra Repositories

Add additional package repositories during the OSTree commit build (not included in final image):

----
$ sudo image-builder build iot-commit \
--distro fedora-43 \
--blueprint iot-custom.toml \
--ostree-ref fedora/stable/x86_64/iot \
--extra-repo 'https://example.com/repo/fedora/43/x86_64' \
--output-dir ./iot-commit-output
----

WARNING: Extra repositories are not GPG checked and only used during the commit build.

=== Customizing Output Names

Customize the output filename for your images:

----
$ sudo image-builder build iot-installer \
--distro fedora-43 \
--ostree-url http://localhost:8000 \
--ostree-ref fedora/stable/x86_64/iot \
--output-name my-custom-installer \
--output-dir ./images
----

=== Verbose Output for Debugging

Enable verbose mode to see detailed build information:

----
$ sudo image-builder build iot-commit \
--distro fedora-43 \
--blueprint iot-custom.toml \
--ostree-ref fedora/stable/x86_64/iot \
--verbose \
--output-dir ./iot-commit-output
----

=== Exporting Build Artifacts

Export the OSBuild manifest and build log for troubleshooting:

----
$ sudo image-builder build iot-commit \
--distro fedora-43 \
--blueprint iot-custom.toml \
--ostree-ref fedora/stable/x86_64/iot \
--with-manifest \
--with-buildlog \
--output-dir ./iot-commit-output
----

== Describing Image Types

To see detailed information about any IoT image type:

----
$ image-builder describe iot-installer --distro fedora-43
$ image-builder describe iot-qcow2 --distro fedora-43 --arch aarch64
$ image-builder describe iot-simplified-installer --distro fedora-43
----

This shows the packages, pipelines, and configuration options for each image type.

== Best Practices

1. \&#42;Test with QCOW2 First\&#42; - Build and test iot-qcow2 images in VMs before creating installation media
2. \&#42;Use Version Control for Blueprints\&#42; - Keep blueprint files in git to track customizations
3. \&#42;Minimize Package Additions\&#42; - Only add essential packages; use containers for applications
4. \&#42;Use Encrypted Passwords\&#42; - Never use plain text passwords in blueprints
5. \&#42;Enable Verbose Mode for Troubleshooting\&#42; - Use \&#96;--verbose\&#96; when debugging build issues

== Troubleshooting

=== Build Fails with OSTree Errors

Verify your local OSTree repository is properly set up and the ref exists:

----
$ ostree --repo=./ostree-repo refs
$ ostree --repo=./ostree-repo show fedora/stable/x86_64/iot
----

Ensure your HTTP server is running and accessible:

----
$ curl http://localhost:8000/config
$ curl http://localhost:8000/refs/heads/fedora/stable/x86_64/iot
----

=== Permission Denied Errors

Most image-builder operations require root privileges:

----
$ sudo image-builder build iot-installer \&#8230;
----

=== Insufficient Disk Space

Building images requires significant disk space. Ensure at least 10GB free in:

\&#42; \&#96;/var/cache/image-builder/\&#96; (build cache)
\&#42; Output directory

Clear cache if needed:

----
$ sudo rm -rf /var/cache/image-builder/store/\&#42;
----

== Additional Resources

\&#42; xref:obtaining-images.adoc[Obtaining Images] - Download pre-built Fedora IoT images
\&#42; xref:booting-the-simplified-provisioner.adoc[Booting the Simplified Provisioner] - Using simplified installer
\&#42; xref:fedora-iot-bootc.adoc[Fedora IoT Bootc] - Bootable container workflows
\&#42; https://github.com/osbuild/image-builder-cli[image-builder CLI] - Source code, documentation, and issue tracker
\&#42; https://www.osbuild.org/[OSBuild Project Documentation]
\&#42; https://ostreedev.github.io/ostree/[OSTree Documentation]


= Setting up a Virtual Machine

== Enable UEFI support for KVM virtual machines
Fedora IoT requires UEFI, take a look at this wiki page on how to make it available for your VM: https://docs.fedoraproject.org/en-US/quick-docs/uefi-with-qemu/

Once everything's set, make sure you enable UEFI for the new VM:

- If using virt-install, add the \&#96;--boot uefi\&#96; flag

- If using Virtual Machine Manager, check \&#96;Customize configuration before install\&#96; before finishing the initial setup -\&gt; Overview -\&gt; Firmware: UEFI -\&gt; Begin Installation

- If using plain \&#96;qemu-kvm\&#96; make sure to point the \&#96;-bios\&#96; flag to the OVMF binary

== Setup with QEMU/KVM Tools
The images generated are compressed raw disk images. They can be utilized both on physical devices and used as disks on a virtualization platform. The images work without change on QEMU/KVM.

On QEMU/KVM the tools that can be used to run the image in a VM include http://virt-manager.org/[Virtual Machine Manager] or \&#96;virsh\&#96; command line utility. These tools are available in most Linux distributions.

Decompress the image as below and then choose an option to import virtual machine.

----
$ xz -d Fedora-IoT-[version].raw.xz
----

TIP: If using iso image, choose the option to create virtual machine and follow the installation steps.

When asked for an installation source or storage location, point to the downloaded disk image.

image::virt-manager-create_new-20190204.png[virt-manager create new dialog]

As your image begins booting, continue with the xref:ignition-device-setup.adoc[Ignition] instructions.

To learn more about the libvirt family of tools used in Fedora, visit the https://docs.fedoraproject.org/en-US/quick-docs/getting-started-with-virtualization/[Getting started with virtualization] section of the Fedora Documentation.

QEMU (on Linux hosts only) also supports user mode emulation. In this mode, QEMU can launch Linux processes compiled for one CPU on another CPU. Learn more in the https://docs.fedoraproject.org/en-US/quick-docs/qemu/[How to use QEMU] section of the Fedora Documentation.

== Setup with virt-install

For fast iterations on the raw image, you can use \&#96;virt-install\&#96;:

----
$ xz -d Fedora-IoT-[version].raw.xz
$ qemu-img convert -f raw Fedora-IoT-[version].raw -O qcow2 Fedora-IoT-[version].qcow2
$ virt-install --name FedoraIoT --memory 2048 --vcpus 2 --boot uefi \
--disk /path/to/Fedora-IoT-[version].qcow2 \
--import --os-variant fedora[version]

----

== Setup with GNOME Boxes

While GNOME Boxes is based on \&#96;libvirt\&#96;, it does not support all of the features and it does not recognize the raw image format. The images we produce need to be converted to to a QCOW2 format. This can be done with the \&#96;qemu-img\&#96; command found in the \&#96;qemu-img\&#96; package.

Decompress and convert the image as below and then create a new virtual machine.

----
$ xz -d Fedora-IoT-[version].raw.xz
$ qemu-img convert -f raw Fedora-IoT-[version].raw -O qcow2 Fedora-IoT-[version].qcow2
----

When asked for an installation source or storage location, point the tool at the existing disk image.

image::new-box-dialog-20190204.png[GNOME Boxes create new dialog]
////
Image should be modified with an outline around the 'Select a file' option
////

As your image begins booting, continue with the xref:ignition-device-setup.adoc[Ignition] instructions.

Alternately, you can install a new box from the ISO image.

image::gnome-boxes-install-00.png[GNOME Boxes New Virtual Machine]

When installing from the ISO image, after selecting the ISO from your filesystem, you'll see that the Operating System has not been found.

image::gnome-boxes-install-01.png[GNOME Boxes Selecting Fedora]

To continue with the installation, type 'Fedora' in the 'Search for an operating system\&#8230;' box and select the 'Fedora' option.

image::gnome-boxes-install-02.png[GNOME Boxes Selecting UEFI]

Once the Fedora Operating System option has been selected, an option to select the Firmware type will appear, select 'UEFI' and continue with the Virtual Machine creation.


////
Link to new (still to be created) page to show ISO install.
SilverBlue has an example with lots of screenshots for the F28 Anaconda install.
It probably has a lot more on manual partitioning than is needed here.
Their intro NOTE is nice in pointing out that it is written in detail, assuming previous Fedora experience.
////

More information on using GNOME Boxes can be found in the https://help.gnome.org/users/gnome-boxes/stable/index.html.en[GNOME HELP] pages.

== Setup with VirtualBox

The images we produce need to be converted to be used with VirtualBox. This can be done with the \&#96;qemu-img\&#96; command found in the \&#96;qemu-img\&#96; package.

Decompress and convert the image as below and then create a new virtual machine.

----
$ xz -d Fedora-IoT-[version].raw.xz
$ qemu-img convert -f raw Fedora-IoT-[version].raw -O vdi Fedora-IoT-[version].vdi
----

When asked for an installation source or storage location, point the tool at the existing disk image.

image::virtualbox-new-dialog-20190204.png[VirtualBox create new hard disk dialog]
////
Image should be modified with an outline around the 'Use an existing'  option
////

As your image begins booting, continue with the xref:ignition-device-setup.adoc[Ignition] instructions.

More information for using Virtual Box can be found at https://www.virtualbox.org/[VirtualBox.org]


= Setting up a Physical Device

== Gather the Physical Components

A list of currently tested devices is maintained in the xref:reference-platforms.adoc[Reference Platforms] page.

Always reference the documentation of the board you have selected for assembly instructions and requirements. At a minimum you will need the board, a power source, and a microSD card.

=== Network connection
If support for your wireless network devices are not available in the Fedora image, it will have to be added after installation.
You will need a wired connection to complete the install of the xref:add-layered.adoc[layered package].

For the Fedora disk images:

\&#42; The Raspberry Pi WiFi is supported in the base image.

=== SD Card
The Fedora IoT image is currently 4GB in size.
The best speed class depends on the usage.
A faster speed class is better for writes but the trade off is slower read speed.

Documentation for your board may also recommend specific SD Card choices as well as required physical sizes for each device.

\&#42; Raspberry Pi discusses card size and speed class in their https://www.raspberrypi.org/documentation/installation/sd-cards.md[SD Card Documentation].

WARNING: The following procedures will overwrite everything on the micro SD card. Be sure to backup any data before continuing!

== Create a Bootable SD Card
If you have not already xref:obtaining-images.adoc[downloaded the image], do so now and make a note of the download location and filename.

=== Determine the SD Card Device name

There are several options for determining the media device name.

\&#42; Run the \&#96;lsblk\&#96; command before and after inserting the card.
The new device that appears on the list is the device for the media.
If your microSD card has partitions, locate the name from the line that is type 'disk'.
In this example the device name is \&#96;mmcblk0\&#96; and will be referenced later as \&#96;/dev/mmcblk0\&#96;:
----
$ lsblk
NAME            MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
mmcblk0         179:0    0  14.9G  0 disk
├─mmcblk0p1     179:1    0   142M  0 part /run/media/user/22DA-CAE8
├─mmcblk0p2     179:2    0     1G  0 part /run/media/user/8b87a5af-12c7-4990-940e-5b457336b11f
└─mmcblk0p3     179:3    0   2.9G  0 part /run/media/user/cce2e189-9aee-4b3e-b031-aac9bdc632c9
\&#8230;output omitted\&#8230;
----
\&#42; If you have the \&#96;udisks2\&#96; package installed you may find the \&#96;udisksctl\&#96; command helpful in determining the media device name. It will show the model and only the device name without the extra partition information. In this example, a 16GB SanDisk Ultra shows as 'SL16G':
----
$ udisksctl status
MODEL                     REVISION  SERIAL               DEVICE
----------------------------------------------------
SAMSUNG MZSLW1T0HMLH-000L1           S308NAAH501124       nvme0n1
SL16G                               0x51821336           mmcblk0
----
\&#42; Finally, the kernel messages will show the addition of a device. In a terminal window before inserting the device run:
----
$ dmesg -w
----

=== Scripted image transfer with \&#96;arm-image-installer\&#96;
\&lt;\&lt;arm-image-installer\&gt;\&gt;
Install the \&#96;arm-image-installer\&#96; package:

----
$ sudo dnf install arm-image-installer
----

Display the usage for the utility.
This will display an example command:

----
$ sudo arm-image-installer

Usage: arm-image-installer \&lt;options\&gt;

--image=IMAGE   - xz compressed image file name
--media=DEVICE  - media device file (/dev/[sdX|mmcblkX])
Optional
--addconsole    - Add system console kernel parameter for the target
--addkey        - /path/to/ssh-public-key
--args          - Optional kernel parameters listed in quotes
--norootpass	- Remove the root password
--relabel       - SELinux relabel root filesystem on first boot
--resizefs      - Resize root filesystem to fill media device
--sysrq		- Enable System Request debugging of the kernel
--target=TARGET	- target board for uboot
-y		- Assumes yes, will not wait for confirmation
Help
--supported     - List of supported hardware
--version       - Display version and exit

Example: arm-image-installer --image=Fedora-Rawhide.xz --target=Bananapi --media=/dev/mmcblk0
----

For the Raspberry Pi Model 3 B/B+ use:

----
--target=rpi3
----

Provide the correct path for the downloaded image and the microSD media.
Replace \&#96;XXX\&#96; with the location of your media. It will be \&#96;sdX\&#96; or \&#96;mmcblkX\&#96; depending on hardware:

----
$ sudo arm-image-installer --image=Fedora-IoT-[version].raw.xz --target=rpi3 --media=/dev/XXX
----

Other options of interest:

\&#42; The \&#96;--addkey=\&#96; option will place a specified ssh public key into the \&#96;/root/authorized_keys\&#96; file (the option expects the path to the key).
\&#42; The \&#96;--resizefs\&#96; options will expand the \&#96;/sysroot\&#96; partition to use all remaining space on the microSD card.

////
\&#42; the \&#96;--addconsole\&#96; option with the \&#96;--target=rpi3\&#96; will modify the config.txt to set enable_uart=1 but there is no extlinux.conf to edit as the help indicates
However, the config.txt also has a comment that:
'u-boot will auto detect serial and pass corrent options to kernel if enabled'
I dont have a setup to test on hand.
////

=== Manual Image Transfer with \&#96;dd\&#96;

Replace \&#96;XXX\&#96; with the location of your media. It will be \&#96;sdX\&#96; or \&#96;mmcblkX\&#96; depending on hardware.

----
xzcat Fedora-IoT-[version].raw.xz | sudo dd status=progress bs=4M of=/dev/XXX
----

== Configure a Serial Console (Optional)

If you wish to use a serial console you'll need to configure it.
Details for the https://fedoraproject.org/wiki/Architectures/ARM/Raspberry_Pi?rd=Raspberry_Pi\&#35;How_do_I_use_a_serial_console.3F[Raspberry PI are here].


== Setup a device by using Ignition and a Raw disk image

=== Prerequisites

\&#42; You have xref:creating-an-ignition-configuration-file.adoc[created an Ignition configuration file] and is accessible via HTTP/HTTPS.
\&#42; You have downloaded a link:https://fedoraproject.org/iot/download[Raw disk image] and copied to media for your device.

=== Edit the boot parameters
As the device boots, edit the kernel args and add the url to your ignition config, for example: \&#96;ignition.config.url=http://192.168.122.1/fiot.ign\&#96;

== Setup a device by using Ignition and the Simplified Provisioner

=== Prerequisites

\&#42; You have xref:creating-an-ignition-configuration-file.adoc[created an Ignition configuration file] and is accessible via HTTP/HTTPS.
\&#42; You have downloaded the link:https://fedoraproject.org/iot/download[Simplified Provisioner ISO image] and booted the device from it by
using one of the methods described in xref:booting-the-simplified-provisioner.adoc[Booting the Simplified Provisioner].


=== Edit the boot parameters

Once device has been booted from the Simplified Provisioner the boot menu shows the
following options:
[subs='attributes']
\&#8230;.
Install Fedora {FedoraVersion}
Test this media \&amp; install Fedora {FedoraVersion}
Troubleshooting --\&gt;
\&#8230;.

\&#42; Select \&#42;'Install Fedora {FedoraVersion}'\&#42; and press the \&#42;'[e]'\&#42; key to edit the menu entry.
\&#42; Make sure the installation device variable (\&#96;coreos.inst.install_dev\&#96;) is correct and
append the ignition parameters (e.g.: \&#96;{SimplifiedProvisionerKernelIgnitionConfigURL} {SimplifiedProvisionerKernelRdNeedNet}\&#96;)
to the \&#96;linux\&#96; line if not present (e.g.:):
+
[subs='attributes']
\&#8230;.
\&#35;\&#35;\&#35; BEGIN /etc/grub.d/10_linux \&#35;\&#35;\&#35;
menuentry 'Install Fedora {FedoraVersion}' --class fedora --class gnu-linux --class gnu --class os {
linux  images/pxeboot/vmlinuz rd.neednet=1 coreos.inst.crypt_root=1 coreos.inst.isoroot=Fedora-{FedoraVersion}-IoT-x86_64 coreos.inst.install_dev=/dev/vda coreos.inst.image_file=/run/media/iso/image.raw.xz coreos.inst.insecure quiet {SimplifiedProvisionerKernelIgnitionConfigURL} {SimplifiedProvisionerKernelRdNeedNet}
initrd images/pxeboot/initrd.img
}
\&#8230;.
\&#42; Boot the menu entry by pressing \&#42;'[Ctrl-x]'\&#42; to boot and install the IoT device

== Verifying the installation

Once the installation has finished and the device has rebooted you should be able to login with the user
configured within the ignition file:
[subs='attributes']
\&#8230;.
ssh core@{DefaultIoTDeviceIP}
\&#8230;.




= Setup a device by using FDO and the Simplified Provisioner

== Prerequisites

\&#42; You have installed and configured the FDO services as described in:
\&#42;\&#42; xref:fdo-installing-the-manufacturing-server-package.adoc[Installing and configuring the Manufacturing server]
\&#42;\&#42; xref:fdo-installing-configuring-and-running-the-rendezvous-server.adoc[Installing and configuring the Rendezvous Server]
\&#42;\&#42; xref:fdo-installing-configuring-and-running-the-owner-server.adoc[Installing and configuring the Owner's Onboarding Server]
\&#42; If using libvirt make sure the FDO server ports are reachable from the VMs
+
[subs='attributes']
\&#8230;.
\&#35; firewall-cmd --zone libvirt \
--add-port={ManufacturingServerPort}/tcp \
--add-port={OwnerOnboardingServerPort}/tcp \
--add-port={RendezvousServerPort}/tcp \
--permanent
\&#35; systemctl restart firewalld
\&#8230;.
\&#42; You have downloaded the link:https://fedoraproject.org/iot/download[Simplified Provisioner ISO image] and booted the device from it by
using one of the methods described in xref:booting-the-simplified-provisioner.adoc[Booting the Simplified Provisioner].


== Edit the boot parameters

Once device has been booted from the Simplified Provisioner the boot menu shows the
following options:
[subs='attributes']
\&#8230;.
Install Fedora {FedoraVersion}
Test this media \&amp; install Fedora {FedoraVersion}
Troubleshooting --\&gt;
\&#8230;.

\&#42; Select \&#42;'Install Fedora {FedoraVersion}'\&#42; and press the \&#42;'[e]'\&#42; key to edit the menu entry.
\&#42; Make sure the installation device variable (\&#96;coreos.inst.install_dev\&#96;) is correct and
append the manufacturing parameters
(\&#96;fdo.manufacturing_server_url=http://{ManufacturingServerIP}:{ManufacturingServerPort} fdo.diun_pub_key_insecure=true\&#96;)
to the \&#96;linux\&#96; line if not present:
+
[subs='attributes']
\&#8230;.
\&#35;\&#35;\&#35; BEGIN /etc/grub.d/10_linux \&#35;\&#35;\&#35;
menuentry 'Install Fedora {FedoraVersion}' --class fedora --class gnu-linux --class gnu --class os {
linux  images/pxeboot/vmlinuz rd.neednet=1 coreos.inst.crypt_root=1 coreos.inst.isoroot=Fedora-{FedoraVersion}-IoT-x86_64 coreos.inst.install_dev=/dev/vda coreos.inst.image_file=/run/media/iso/image.raw.xz coreos.inst.insecure quiet fdo.manufacturing_server_url=http://{ManufacturingServerIP}:{ManufacturingServerPort} fdo.diun_pub_key_insecure=true
initrd images/pxeboot/initrd.img
}
\&#8230;.
\&#42; Boot the menu entry by pressing \&#42;'[Ctrl-x]'\&#42;
\&#42; Once the IoT device has been installed and performed the manufacturing process it will reboot and perform the FDO Onboarding in the next boot.

== Verifying the Onboarding

If the onboarding finished successfully you sould be able to login with the initial user configured in the Service Info API server.

When using libvirt in the same host where the FDO services are running you can use the following command to connect to the VM:
[subs='attributes']
\&#8230;.
\&#35;! /bin/bash

export LIBVIRT_DEFAULT_URI=qemu:///system
export LIBVIRT_DOMAIN_NAME={VMName}
export LIBVIRT_NETWORK=default

MAC=$(virsh domiflist '$\{LIBVIRT_DOMAIN_NAME\}' | grep '$\{LIBVIRT_NETWORK\}' | awk '{print $5}')
IP=$(virsh net-dhcp-leases '$\{LIBVIRT_NETWORK\}'| grep '$\{MAC\}' | awk '{print $5}'| cut -f1 -d/)
ssh admin@$\{IP\}
\&#8230;.



= The FIDO Device Onboarding (FDO) process

The FIDO Device Onboarding (FDO) is the process that:

\&#42; Provisions and onboards a device.
\&#42; Automatically configures credentials for this device. The FDO process is an
automatic onboarding mechanism that is triggered by the installation of a new
device.
\&#42; Enables this device to securely connect and interact on the network.

With FIDO Device Onboarding (FDO), you can perform a secure device onboarding
by adding new devices into your IoT architecture. This includes the specified
device configuration that needs to be trusted and integrated with the rest of
the running systems. The FDO process is an automatic onboarding mechanism that
is triggered by the installation of a new device.

The FDO protocol performs the following tasks:

\&#42; Solves the trust and chain of ownership along with the automation needed to
securely onboard a device at scale.
\&#42; Performs device initialization at the manufacturing stage and late device
binding for its actual use. This means that actual binding of the device to a
management system happens on the first boot of the device without requiring
manual configuration on the device.
\&#42; Supports automated secure devices onboarding, that is, zero touch
installation and onboarding that does not need any specialized person at the
edge location. After the device is onboarded, the management platform can
connect to it and apply patches, updates, and rollbacks.

With FDO, you can benefit from the following:

\&#42; FDO is a secure and simple way to enroll a device to a management platform.
Instead of embedding a Kickstart configuration to the image, FDO applies the
device credentials during the device first boot directly to the ISO image.
\&#42; FDO solves the issue of late binding to a device, enabling any sensitive
data to be shared over a secure FDO channel.
\&#42; FDO cryptographically identifies the system identity and ownership before
enrolling and passing the configuration and other secrets to the system. That
enables non-technical users to power-on the system.

To build a Fedora IoT Simplified Provisioner image and automatically onboard it,
provide an existing OSTree commit. The resulting simplified image contains a
raw image that has the OSTree commit deployed. After you boot the Simplified
installer ISO image, it provisions a Fedora IoT system that you can use on a
hard disk or as a boot image in a virtual machine.

The Fedora IoT Simplified Provisioner image is optimized for unattended
installation to a device and supports both network-based deployment and
non-network-based deployments. However, for network-based deployment, it
supports only UEFI HTTP boot.

The FDO protocol is based on the following servers:

Manufacturing server::
+
. Generates the device credentials.
. Creates an Ownership voucher that is used to set the ownership of the device,
later in the process.
. Binds the device to a specific management platform.

Owner management system::
+
. Receives the Ownership voucher from the Manufacturing server and becomes the
owner of the associated device.
. Later in the process, it creates a secure channel between the device and
the owner onboarding server after the device authentication.
. Uses the secure channel to send the required information, such as files and
scripts for the onboarding automation to the device.

Service-info API server::
+
Based on Service-info API server's configuration and modules available on the
client, it performs the final steps of onboarding on target client devices,
such as copying SSH keys and files, executing commands, creating users,
encrypting disks and so on

Rendezvous server::
+
. Gets the Ownership voucher from the Owner management system and makes a
mapping of the device UUID to the Owner server IP. Then, the Rendezvous server
matches the device UUID with a target platform and informs the device about
which Owner onboarding server endpoint this device must use.

. During the first boot, the Rendezvous server will be the contact point for
the device and it will direct the device to the owner, so that the device and
the owner can establish a secure channel.

Device client::
+
This is installed on the device. The Device client performs the following actions:

. Starts the queries to the multiple servers where the onboarding automation will
be executed.
. Uses TCP/IP protocols to communicate with the servers.

The following diagram represents the FIDO device onboarding workflow:
.Deploying Fedora IoT in non-network environment

image::FDO_Process.png[FDO device onboarding]

At the \&#42;Device Initialization\&#42;, the device contacts the Manufacturing server to
get the FDO credentials, a set of certificates and keys to be installed on the
operating system with the Rendezvous server endpoint (URL). It also gets the
Ownership Voucher, that is maintained separately in case you need to change the
owner assignment.

. The Device contacts the Manufacturing server
. The Manufacturing server generates an Ownership Voucher and the Device
Credentials for the Device.
. The Ownership Voucher is transferred to the Owner onboarding server.

At the \&#42;On-site onboarding\&#42;, the Device gets the Rendezvous server endpoint
(URL) from its device credentials and contacts Rendezvous server endpoint to
start the onboarding process, which will redirect it to the Owner management
system, that is formed by the Owner onboarding server and the Service Info
API server.

. The Owner onboarding server transfers the Ownership Voucher to the Rendezvous
server, which makes a mapping of the Ownership Voucher to the Owner.
. The device client reads device credentials.
. The device client connects to the network.
. After connecting to the network, the Device client contacts the Rendezvous
server.
. The Rendezvous server sends the owner endpoint URL to the Device Client, and
registers the device.
. The Device client connects to the Owner onboarding server shared by the
Rendezvous server.
. The Device proves that it is the correct device by signing a statement with a
device key.
. The Owner onboarding server proves itself correct by signing a statement with
the last key of the Owner Voucher.
. The Owner onboarding server transfers the information of the Device to the
Service Info API server.
. The Service info API server sends the configuration for the Device.
. The Device is onboarded.



= Generating key and certificates

To run the FIDO Device Onboarding (FDO) infrastructure, you need to generate
keys and certificates. FDO generates these keys and certificates to configure
the manufacturing server. FDO automatically generates the certificates and
\&#96;.yaml\&#96; configuration files when you install the services, and re-creating them
is optional. After you install and start the services, it runs with the default
settings.

.Prerequisites

\&#42; You installed the \&#96;fdo-admin-cli\&#96; RPM package

.Procedure

. Generate the keys and certificates in the \&#96;/etc/fdo\&#96; directory:
+
[subs='attributes']
----
$ for i in 'diun' 'manufacturer' 'device-ca' 'owner'; do
fdo-admin-tool generate-key-and-cert $i;
done
----

. Check the key and certificates that were created in the \&#96;/etc/fdo/keys\&#96; directory:
+
[subs='attributes']
----
$ tree keys
----
+
You can see the following output:
+
[subs='attributes']
----
keys/
├── device_ca_cert.pem
├── device_ca_key.der
├── diun_cert.pem
├── diun_key.der
├── manufacturer_cert.pem
├── manufacturer_key.der
├── owner_cert.pem
└── owner_key.der
----

.Additional resources
\&#42; See the \&#96;fdo-admin-tool generate-key-and-cert –-help\&#96; manual page




= Installing and running the manufacturing server

The \&#96;fdo-manufacturing-server\&#96; RPM package enables you to run the Manufacturing
Server component of the FDO protocol. It also stores other components, such as
the owner vouchers, the manufacturer keys, and information about the manufacturing
sessions. During the device installation, the Manufacturing server generates the
device credentials for the specific device, including its GUID, rendezvous
information and other metadata. Later on in the process, the device uses this
rendezvous information to contact the Rendezvous server.

To install the \&#96;manufacturing server\&#96; RPM package, complete the following steps:

.Procedure

. Install the \&#96;fdo-admin-cli\&#96; package:
+
[subs='attributes']
----
\&#35; dnf install -y fdo-admin-cli
----

. Check if the \&#96;fdo-manufacturing-server\&#96; RPM package is installed:
+
[subs='attributes']
----
$ rpm -qa | grep fdo-manufacturing-server --refresh
----

. Check if the files were correctly installed:
+
[subs='attributes']
----
$ ls /usr/share/doc/fdo
----
+
You can see the following output:
+
[subs='attributes']
----
manufacturing-server.yml
owner-onboarding-server.yml
rendezvous-info.yml
rendezvous-server.yml
serviceinfo-api-server.yml
----

. Optional: Check the content of each file, for example:
+
[subs='attributes']
----
$ cat /usr/share/doc/fdo/manufacturing-server.yml
----

. Configure the Manufacturing server. You must provide the following information:

\&#42; The Manufacturing server URL
\&#42; The IP address or DNS name for the Rendezvous server
\&#42; The path to the keys and certificates you generated. See xref:fdo-generating-key-and-certificates.adoc[Generating key and certificates].
+
You can find an example of a Manufacturing server configuration file in the
\&#96;/usr/share/doc/fdo/manufacturing-server.yml\&#96; directory. The following is a
\&#96;manufacturing server.yml\&#96; example that is created and saved in the \&#96;/etc/fdo\&#96;
directory. It contains paths to the directories, certificates, keys that you
created, the Rendezvous server IP address and the default port.
+
[subs='attributes']
----
session_store_driver:
Directory:
path: /etc/fdo/stores/manufacturing_sessions/
ownership_voucher_store_driver:
Directory:
path: /etc/fdo/stores/owner_vouchers
public_key_store_driver:
Directory:
path: /etc/fdo/stores/manufacturer_keys
bind: '0.0.0.0:{ManufacturingServerPort}'
protocols:
plain_di: false
diun:
mfg_string_type: SerialNumber
key_type: SECP384R1
allowed_key_storage_types:
- Tpm
- FileSystem
key_path: /etc/fdo/keys/diun_key.der
cert_path: /etc/fdo/keys/diun_cert.pem
rendezvous_info:
- deviceport: {RendezvousServerPort}
ip_address: {RendezvousServerIP}
ownerport: {RendezvousServerPort}
protocol: http
manufacturing:
manufacturer_cert_path: /etc/fdo/keys/manufacturer_cert.pem
device_cert_ca_private_key: /etc/fdo/keys/device_ca_key.der
device_cert_ca_chain: /etc/fdo/keys/device_ca_cert.pem
owner_cert_path: /etc/fdo/keys/owner_cert.pem
manufacturer_private_key: /etc/fdo/keys/manufacturer_key.der
----

. Start the Manufacturing server.
.. Check if the systemd unit file are in the server:
+
[subs='attributes']
----
\&#35; systemctl list-unit-files | grep fdo | grep manufacturing
fdo-manufacturing-server.service disabled disabled
----

.. Enable and start the manufacturing server.
+
[subs='attributes']
----
\&#35; systemctl enable --now fdo-manufacturing-server.service
----

.. Open the default ports in your firewall:
+
[subs='attributes']
----
\&#35; firewall-cmd --add-port={ManufacturingServerPort}/tcp --permanent
\&#35; systemctl restart firewalld
----

.. Ensure that the service is listening on the port 8080:
+
[subs='attributes']
----
\&#35; ss -ltn
----

. Install Fedora IoT onto your system using the Simplified Provisioner. See xref:fdo-device-setup.adoc[Setting up a Device with FDO].

.Additional resources
\&#42; The link:https://github.com/fedora-iot/fido-device-onboard-rs/blob/main/examples/config/manufacturing-server.yml[manufacturing-server.yml example]
\&#42; xref:fdo-glossary.adoc[FIDO device onboarding glossary]


= Installing, configuring, and running the Rendezvous server

Install the \&#96;fdo-rendezvous-server\&#96; RPM package to enable the systems to
receive the voucher generated by the Manufacturing server during the first
device boot. The Rendezvous server then matches the device UUID with the
target platform or cloud and informs the device about which Owner server
endpoint the device must use.

.Prerequisites

\&#42; You created a \&#96;manufacturer_cert.pem\&#96; certificate.
See xref:fdo-generating-key-and-certificates.adoc[Generating key and certificates].
\&#42; You copied the \&#96;manufacturer_cert.pem\&#96; certificate to the \&#96;/etc/fdo/keys\&#96;
directory in the Rendezvous server.


.Procedure

. Install the \&#96;fdo-rendezvous-server\&#96; RPM packages:
+
----
\&#35; dnf install -y fdo-rendezvous-server
----

.  Create the \&#96;rendezvous-server.yml\&#96; configuration file, including the path to
the manufacturer certificate. You can find an example in
\&#96;/usr/share/doc/fdo/rendezvous-server.yml\&#96;. The following example shows a
configuration file that is saved in \&#96;/etc/fdo/rendezvous-server.yml\&#96;.
+
----
storage_driver:
Directory:
path: /etc/fdo/stores/rendezvous_registered
session_store_driver:
Directory:
path: /etc/fdo/stores/rendezvous_sessions
trusted_manufacturer_keys_path: /etc/fdo/keys/manufacturer_cert.pem
max_wait_seconds: ~
bind: '0.0.0.0:8082'
----

. Check the Rendezvous server service status:
+
----
\&#35; systemctl list-unit-files | grep fdo | grep rende
fdo-rendezvous-server.service disabled disabled
----

..  If the service is stopped and disabled, enable and start it:
+
----
\&#35; systemctl enable --now fdo-rendezvous-server.service
----

. Check that the server is listening on the default configured port 8082:
+
----
\&#35; ss -ltn
----

. Open the port if you have a firewall configured on this server:
+
----
\&#35; firewall-cmd --add-port=8082/tcp --permanent
\&#35; systemctl restart firewalld
----





= Installing, configuring, and running the Owner server

Install the \&#96;fdo-owner-cli\&#96; and \&#96;fdo-owner-onboarding-server\&#96; RPM package to
enable the systems to receive the voucher generated by the Manufacturing server
during the first device boot. The Rendezvous server then matches the device
UUID with the target platform or cloud and informs the device about which Owner
server endpoint the device must use.

.Prerequisites

\&#42; The device where the server will be deployed has a Trusted Platform Module
(TPM) device to encrypt the disk. If not, you will get an error when booting
the Fedora IoT device.
\&#42; You created the \&#96;device_ca_cert.pem\&#96;, \&#96;owner_key.der\&#96;, and \&#96;owner_cert.pem\&#96;
with keys and certificates and copied them into the \&#96;/etc/fdo/keys\&#96; directory.

.Procedure

. Install the required RPMs in this server:
+
[subs='attributes']
----
\&#35; dnf install -y fdo-owner-cli fdo-owner-onboarding-server
----

. Prepare the \&#96;owner-onboarding-server.yml\&#96; configuration file and save it to
the \&#96;/etc/fdo/\&#96; directory. Include the path to the certificates you already
copied and information about where to publish the Owner server service in this
file.
+
The following is an example available in
\&#96;/usr/share/doc/fdo/owner-onboarding-server.yml\&#96;. You can find references to
the Service Info API, such as the URL or the authentication token.
+
[subs='attributes']
----
---
ownership_voucher_store_driver:
Directory:
path: /etc/fdo/stores/owner_vouchers
session_store_driver:
Directory:
path: /etc/fdo/stores/owner_onboarding_sessions
trusted_device_keys_path: /etc/fdo/keys/device_ca_cert.pem
owner_private_key_path: /etc/fdo/keys/owner_key.der
owner_public_key_path: /etc/fdo/keys/owner_cert.pem
bind: '0.0.0.0:{OwnerOnboardingServerPort}'
service_info_api_url: 'http://{ServiceInfoServerIP}:{ServiceInfoServerPort}/device_info'
service_info_api_authentication:
BearerToken:
token: Kpt5P/5flBkaiNSvDYS3cEdBQXJn2Zv9n1D50431/lo=
owner_addresses:
- transport: http
addresses:
- ip_address: {OwnerOnboardingServerIP}
port: {OwnerOnboardingServerPort}
----

. Create and configure the Service Info API.
.. Add the automated information for onboarding, such as user creation, files
to be copied or created, commands to be executed, disk to be encrypted, and so
on. Use the Service Info API configuration file example in
\&#96;/usr/share/doc/fdo/serviceinfo-api-server.yml\&#96; as a template to create the
configuration file under \&#96;/etc/fdo/\&#96;.
+
[subs='attributes']
----
---
service_info:
initial_user:
username: admin
sshkeys:
- 'ssh-rsa AAAA\&#8230;.'
diskencryption_clevis:
- disk_label: /dev/vda3
binding:
pin: tpm2
config: '{}'
reencrypt: true
bind: '0.0.0.0:{ServiceInfoServerPort}'
device_specific_store_driver:
Directory:
path: /etc/fdo/stores/serviceinfo_api_devices
service_info_auth_token: Kpt5P/5flBkaiNSvDYS3cEdBQXJn2Zv9n1D50431/lo=
admin_auth_token: zJNoErq7aa0RusJ1w0tkTjdITdMCWYkndzVv7F0V42Q=
----

. Check the status of the systemd units:
+
[subs='attributes']
----
\&#35; systemctl list-unit-files | grep fdo
fdo-owner-onboarding-server.service        disabled        disabled
fdo-serviceinfo-api-server.service         disabled        disabled
----

..  If the service is stopped and disabled, enable and start it:
+
[subs='attributes']
----
\&#35; systemctl enable --now fdo-owner-onboarding-server.service
\&#35; systemctl enable --now fdo-serviceinfo-api-server.service
----
+
NOTE: You must restart the \&#96;systemd\&#96; services every time you change the configuration files.

. Check that the server is listening on the default configured port 8083:
+
[subs='attributes']
----
\&#35; ss -ltn
----

. Open the port if you have a firewall configured on this server:
+
[subs='attributes']
----
\&#35; firewall-cmd --add-port={OwnerOnboardingServerPort}/tcp --permanent
\&#35; firewall-cmd --add-port={ServiceInfoServerPort}/tcp --permanent
\&#35; systemctl restart firewalld
----



= FIDO device onboarding glossary

Learn more about the FIDO device onboarding terminology.

.FDO glossary

|===
| Term                   | Description

| FDO                    | FIDO Device Onboarding.
| Device                 | Any hardware, device, or computer.
| Device Credential (DC) | Key credential and rendezvous stored in the device at manufacture.
| Keys                   a| Keys to configure the manufacturing server

\&#42; key_path

\&#42; cert_path

\&#42; key_type

\&#42; mfg_string_type: device serial number

\&#42; allowed_key_storage_types: Filesystem and Trusted Platform Module (TPM) that protects the data used to authenticate the device you are using.

| Manufacturer           | The device manufacturer.
| Manufacturer server    | Creates the device credentials for the device.
| Manufacturer client    | Informs the location of the manufacturing server.
| Owner                  | The final owner of the device - a company or an IT department.
| Ownership Voucher (OV) a| Record of ownership of an individual device.

Contains the following information:

\&#42; Owner (\&#96;fdo-owner-onboarding-service\&#96;)

\&#42; Rendezvous Server - FIDO server (\&#96;fdo-rendezvous-server\&#96;)

\&#42; Device (at least one combination)  (\&#96;fdo-manufacturing-service\&#96;)

| Rendezvous server      | Link to a server used by the device and later on, used on the process to find out who is the owner of the device
|===

.Additional resources
\&#42; https://fidoalliance.org/specs/fidoiot/FIDO-IoT-spec-v1.0-wd-20200730.html\&#35;OV[FIDO IoT spec]



= Network Access

Before removing the serial console or HDMI monitor and USB keyboard, verify network connectivity.
The provided images default to obtaining network settings from a DHCP server.

== Verify Network Configuration

Determine your IP address:

----
$ ip addr
----

Check that you have a default gateway:

----
$ ip route
----

Ping a known host:

----
$ ping -c3 iot.fedoraproject.org
----

NOTE: The sample above requires name resolution and a route to the internet.
If your device is located on an isolated network, ping another host on your network.

Verify that \&#96;sshd\&#96; is running:

----
$ systemctl is-active sshd
----

View the default firewall configuration:

----
$ sudo firewall-cmd --list-all
----

NOTE: Information on adding support for specific devices can be found in the xref:user-guide.adoc[User Guide].

== Configure Remote Access

Once the initial setup is complete, the serial console or HDMI monitor and USB keyboard are no longer required to access the device.
The device can be left in a headless state and accessed remotely.

The released images are configured to run an SSH server and accept outside connections.
The default configuration allows root login if a password is set.
This is a good reason to leave the root account locked.
The default configuration also allows standard users to login and the user can then sudo if they were made an administrator as a member of the wheel group.

----
$ ssh testuser@11.22.33.44
----

.Authentication Failures
[TIP]
====
If receive a 'Too many authentication failures' message such as:

----
Received disconnect from 11.22.33.44 port 22:2: Too many authentication failures
----

you may have too many different ssh keys in your personal ssh configuration directory.
Since the image does not have your key, try connecting with a password first using:

----
$ ssh -o PreferredAuthentications=password testuser@11.22.33.44
----

If this works, you can customize your ssh configuration to specify either this option or options to use a specific key once you have added your keys.
====

NOTE: More information on managing accounts, keys, and remote access can be found in the xref:user-guide.adoc[User Guide].

////
Other topics to include in User Guide:
Disabling root ssh access for security compliance.
Adding ssh keys to user or host authorized keys file.
(Rare in IoT?) setting a hostname and/or any /etc/hosts settings
(Rare, developer only?) Static networking options
(consider) Any comments on how virt platforms tend to default to NAT network that might make remote access a bit more challenging.
////



= Boot the Simplified Provisioner

== Boot from the Simplified Provisioner ISO

\&#42; If you are using physical devices with a CD-ROM unit:
\&#42;\&#42; Burn the downloaded Simplified Provisioner ISO to a CD-ROM
\&#42;\&#42; Use the CD-ROM to boot the IoT device from it.
\&#42; If you are using Virtual Machines, you can use the \&#96;virt-install\&#96;
command to boot from the Simplified Provisioner ISO.
+
[subs='attributes']
\&#8230;.
\&#35; virt-install --connect qemu:///system \
--name '{VMName}' \
--os-variant '{OSVariant}' \
--boot uefi,loader.secure=false \
--vcpus {VMCPUs} --memory {VMMemory} \
--network network=default,model=virtio \
--disk pool=default,size=30 \
--cdrom {FedoraSimplifiedProvisionerISO}
\&#8230;.

== Boot the Simplified Provisioner from an USB Flash Drive

\&#42; Copy the ISO image file to a USB flash drive (You will need a 8 GB USB flash drive at least)
\&#42; Connect the USB flash drive to the port of the computer you want to boot.
\&#42; Boot the device from the USB flash drive.

== Boot the Simplified Provisioner from UEFI HTTP Boot

\&#42; Copy the contents of the Simplified Provisioner ISO to a directory
+
[subs='attributes']
\&#8230;.
mount {FedoraSimplifiedProvisionerISO} /mnt
cp -r /mnt Fedora-{FedoraVersion}-IoT-Simplified-Provisioner
cd Fedora-{FedoraVersion}-IoT-Simplified-Provisioner
\&#8230;.
\&#42; Modify the \&#96;grub.cfg\&#96; file in \&#96;EFI/BOOT\&#96; directory and replace all the
instances of \&#96;linux\&#96; and \&#96;initrd\&#96; with \&#96;linuxefi\&#96; and \&#96;initrdefi\&#96; respectively.
+
[subs='attributes']
\&#8230;.
sed -i -e 's|linux /|linuxefi /|' \
-e 's|initrd /|initrdefi /|' \
EFI/BOOT/grub.cfg
\&#8230;.
\&#42; Use an HTTP Server to serve the contents over the network, e.g.:
+
[subs='attributes']
\&#8230;.
python3 -m http.server {UEFIHTTPBootServerPort}
firewall-cmd --add-port={UEFIHTTPBootServerPort}/tcp
\&#8230;.

\&#42; The correct URL to perform UEFI HTTPBoot depends on the ISO architecture (\&#96;x86_64\&#96; or \&#96;aarch64\&#96;)
\&#42;\&#42; For \&#96;x86_64\&#96; hardware the corresponding HTTP URL of
\&#96;EFI/BOOT/BOOTX86.EFI\&#96; file will be used to boot (e.g. \&#96;http://{UEFIHTTPBootServerIP}:{UEFIHTTPBootServerPort}/EFI/BOOT/BOOTX86.EFI\&#96;)
\&#42;\&#42; For \&#96;aarch64\&#96; hardware the corresponding HTTP URL of
\&#96;EFI/BOOT/BOOTAA64.EFI\&#96; file will be used to boot (e.g. \&#96;http://{UEFIHTTPBootServerIP}:{UEFIHTTPBootServerPort}/EFI/BOOT/BOOTAA64.EFI\&#96;)

=== Booting Physical Servers

\&#42; If using a physical server please check the manual or Management UI interface
to see if the system supports UEFI HTTPBoot and follow the steps in the manual
to boot it manually or in an automated way from the boot URL (see above)

=== Booting Virtual Machines

\&#42; Use the \&#96;virt-install\&#96; command (or any other tool that supports booting UEFI VMs) to boot a VM. E.g.:
+
[subs='attributes']
\&#8230;.
virt-install --connect qemu:///system \
--name '{VMName}' \
--os-variant '{OSVariant}' \
--boot uefi,loader.secure=false \
--vcpus {VMCPUs} --memory {VMMemory}  \
--network network=default,model=virtio \
--disk pool=default,size=30 \
--import
\&#8230;.

\&#42; Press \&#42;'[Esc]'\&#42; key repeately to enter the UEFI management interface
\&#42; Select \&#42;'Device Manager'\&#42; and press \&#42;'[Enter]'\&#42;
\&#42; Select \&#42;'Network Device List'\&#42; and press \&#42;'[Enter]'\&#42;
\&#42; Select the MAC address corresponding to the interface you wan to use to perform UEFI HTTPBoot and press \&#42;'[Enter]'\&#42;
\&#42; Select \&#42;'HTTP Boot Configuration'\&#42; and press \&#42;'[Enter]'\&#42;
\&#42; Select \&#42;'Boot URI'\&#42; and press \&#42;'[Enter]'\&#42;
\&#42; Enter the HTTPBoot URL (see above) (e.g.: \&#42;http://{UEFIHTTPBootServerIP}:{UEFIHTTPBootServerPort}/EFI/BOOT/BOOTX86.EFI\&#42;) and press \&#42;'[Enter]'\&#42;
\&#42; Press \&#42;'[F10]'\&#42; key to save the changes and then press \&#42;'[Y]'\&#42; to confirm the action
\&#42; Press \&#42;'[Esc]'\&#42; four times until you return to the main screen
\&#42; Select \&#42;'Boot Manager'\&#42;
\&#42; Select \&#42;'UEFI HTTP'\&#42; and press \&#42;'[Enter]'\&#42;
\&#42; The VM should perform the UEFI HTTPBoot.

It's also possible to perform the same steps in an automated way by modifying the UEFI vars after creating the virtual
machine. For that we will need to install the \&#96;qemu-img\&#96; and \&#96;python3-virt-firmware\&#96; packages:
[subs='attributes']
\&#8230;.
dnf install -y python3-virt-firmware qemu-img
\&#8230;.

\&#42; Create an unitialized and stopped virtual machine (make sure it supports UEFI), e.g.:
+
[subs='attributes']
\&#8230;.
virt-install --connect qemu:///system \
--name '{VMName}' \
--os-variant '{OSVariant}' \
--boot uefi,loader.secure=false \
--vcpus {VMCPUs} --memory {VMMemory}  \
--network network=default,model=virtio \
--disk pool=default,size=30 \
--import --noautoconsole --noreboot
\&#8230;.
\&#42; Connect the QCOW2 containing the VM's UEFI variables to an NBD disk so we can modify them inplace:
+
[subs='attributes']
\&#8230;.
modprobe nbd
qemu-nbd --connect /dev/nbd0 /var/lib/libvirt/qemu/nvram/{VMName}_VARS.qcow2
\&#8230;.
\&#42; Use the \&#96;virt-fw-vars\&#96; tool to modify the UEFI variables and configure the VM to boot from the HTTP URL, e.g.:
+
[subs='attributes']
\&#8230;.
virt-fw-vars --input /dev/nbd0 --set-boot-uri http://{UEFIHTTPBootServerIP}:{UEFIHTTPBootServerPort}/EFI/BOOT/BOOTX64.EFI
\&#8230;.
\&#42; Disconnect the NBD device:
+
[subs='attributes']
\&#8230;.
qemu-nbd --disconnect /dev/nbd0
\&#8230;.
\&#42; Start the VM:
+
[subs='attributes']
\&#8230;.
virsh --connect qemu:///system \
start {VMName}
\&#8230;.
\&#42; The VM should perform an UEFI HTTPBoot from the configured URL




== Customizing the Simplified Provisioner ISO

Fedora IoT provides a generic Simplified Provisioning ISO that is by default configured to install to a virtual disk (\&#96;/dev/vda\&#96;). This can be customized for your device depending on what hardware you have (nvme0, sda, mmcblk0) and configuration option you would like to leverage - FDO or Ignition.

=== Prerequisites

\&#42; Recent simplified-provisioning ISO
\&#42; Fedora system with \&#96;lorax\&#96; installed, which provides the \&#96;mkksiso\&#96; tool (sudo dnf install lorax).
\&#42; To use FDO, you have installed and configured the FDO services as described in:
\&#42;\&#42; xref:fdo-installing-the-manufacturing-server-package.adoc[Installing and configuring the Manufacturing server]
\&#42;\&#42; xref:fdo-installing-configuring-and-running-the-rendezvous-server.adoc[Installing and configuring the Rendezvous Server]
\&#42;\&#42; xref:fdo-installing-configuring-and-running-the-owner-server.adoc[Installing and configuring the Owner's Onboarding Server]
\&#42; To use Ignition, you have created a configuration file as described in:
\&#42;\&#42; xref:creating-an-ignition-configuration-file.adoc[Creating an Ignition configuration file]

== Creating a custom Simplified Provisioner

With use of the \&#96;mkksiso\&#96; tool its possible to create a customized installer that can be used to install and configure most devices.

=== Example with FIDO Device Onboard

This example:

\&#42; Uses the \&#96;--cmdline\&#96; option to add the \&#96;fdo.manufacturing_server_url\&#96; to specify the FDO Manufacturing server to be used during the installation. NOTE: Replace the URL with that of your FDO Manufacturing server url.
\&#42; Uses the \&#96;--replace\&#96; option to update the installation device and remove the \&#96;quiet\&#96; option from the kernel arguments so boot message are shown on screen
\&#42; Uses the generic ISO - \&#96;Fedora-IoT-provisioner-42-20250618.0.x86_64.iso\&#96; creating a new ISO named \&#96;Fedora-IoT-provisioner-FDO-42-20250618.0.x86_64.iso\&#96;
[subs='attributes']

\&#8230;.
sudo mkksiso --cmdline 'fdo.manufacturing_server_url=http://192.168.1.26:8080 fdo.diun_pub_key_insecure=true' \
--replace quiet '' \
--replace vda sda \
Fedora-IoT-provisioner-42-20250618.0.x86_64.iso Fedora-IoT-provisioner-FDO-42-20250618.0.x86_64.iso
\&#8230;.

=== Example with Ignition

This example:

\&#42; Uses the \&#96;--cmdline\&#96; option to add the \&#96;ignition.config.url\&#96; to specify the location of the Ignition configuration file. NOTE: Replace the URL with that of your Ignition file.
\&#42; Uses the \&#96;--replace\&#96; option to update the installation device to use \&#96;nvme0\&#96;
\&#42; Uses the generic ISO - \&#96;Fedora-IoT-provisioner-42-20250618.0.x86_64.iso\&#96; creating a new ISO named \&#96;Fedora-IoT-provisioner-IGN-42-20250618.0.x86_64.iso\&#96;
[subs='attributes']

\&#8230;.
sudo mkksiso --cmdline 'coreos.inst.append=ignition.config.url=http://192.168.1.25/configs/ignition/config.ign' \
--replace vda nvme0 \
Fedora-IoT-provisioner-42-20250618.0.x86_64.iso Fedora-IoT-provisioner-IGN-42-20250618.0.x86_64.iso
\&#8230;.

== Troubleshooting issues
[subs='attributes']

When troubleshooting issues with the Simplified-Provisioner it may be helpful to use the \&#96;coreos.inst.skip_reboot\&#96; option to prevent automatic reboot after installation completes.



= Creating an Ignition configuration file

The \&#96;Butane\&#96; tool is the preferred option to create an Ignition configuration
file. \&#96;Butane\&#96; consumes a \&#96;Butane Config YAML\&#96; file and produces an
\&#96;Ignition Config\&#96; in the JSON format. The JSON file is used by a system on its
first boot. The \&#96;Ignition Config\&#96; applies the configuration in the image, such
as user creation, and \&#96;systemd\&#96; units installation.

.Prerequisites

\&#42; You have installed podman or link:https://github.com/coreos/butane/releases/tag/v0.20.0[Butane v0.20.0] or later:

.Procedure

. Create a \&#96;Butane Config\&#96; file and save it in the \&#96;.bu\&#96; format. You must
specify the \&#96;variant\&#96; entry as \&#96;fiot\&#96;, and the \&#96;version\&#96; entry as \&#96;1.0.0\&#96;,
for Fedora IoT images. The butane \&#96;fiot\&#96; variant on version 1.0.0 targets
Ignition spec version \&#96;3.3.0\&#96;. The following is a Butane Config YAML file
example:
+
[subs='attributes']
----
variant: fiot
version: 1.0.0
ignition:
config:
merge:
- source: http://{DefaultServerIP}/config.ign
passwd:
users:
- name: core
groups:
- wheel
password_hash: password_hash_here
ssh_authorized_keys:
- ssh-ed25519 some-ssh-key-here
storage:
files:
- path: /etc/NetworkManager/system-connections/enp1s0.nmconnection
contents:
inline: |
[connection]
id=enp1s0
type=ethernet
interface-name=enp1s0
[ipv4]
address1={DefaultIotDeviceIP}/{DefaultNetworkPrefix},{DefaultGateway}
dns=8.8.8.8;
dns-search=
may-fail=false
method=manual
mode: 0600
- path: /usr/local/bin/startup.sh
contents:
inline: |
\&#35;!/bin/bash
echo 'Hello, World!'
mode: 0755
systemd:
units:
- name: hello.service
contents: |
[Unit]
Description=A hello world
[Install]
WantedBy=multi-user.target
enabled: true
- name: fdo-client-linuxapp.service
dropins:
- name: log_trace.conf
contents: |
[Service]
Environment=LOG_LEVEL=trace
----

. Run the following command to consume the \&#96;Butane Config YAML\&#96; file and
generate an Ignition Config in the JSON format:
+
[subs='attributes']
----
$ podman run -i --rm quay.io/coreos/butane --pretty --strict \&lt; fiot.bu | tee fiot.ign
{
'ignition': {
'config': {
'merge': [
{
'source': 'http://192.168.122.1/config.ign'
}
]
},
'version': '3.4.0'
},
'passwd': {
'users': [
{
'groups': [
'wheel'
],
'name': 'core',
'passwordHash': 'password_hash_here',
'sshAuthorizedKeys': [
'ssh-ed25519 some-ssh-key-here'
]
}
]
},
'storage': {
'files': [
{
'path': '/etc/NetworkManager/system-connections/enp1s0.nmconnection',
'contents': {
'compression': 'gzip',
'source': 'data:;base64,H4sIAAAAAAAC/1SKwQrCMBAF7/stNjahSEX2S0oPS/JKA822JKvQvxcFDzKnGWaKuyqi5V1nyomhh2892XmAYSuqwiiroS4S0akU/J4pH69hJkmpojXP/h6cv43Oh+B8fw3D5a9Q0saj+/L4SNcgNa5MRc5ukbzxIlsDFdi6Jy6iT9noHQAA//9IedCQoQAAAA=='
},
'mode': 384
},
{
'path': '/usr/local/bin/startup.sh',
'contents': {
'compression': '',
'source': 'data:;base64,IyEvYmluL2Jhc2gKZWNobyAiSGVsbG8sIFdvcmxkISIK'
},
'mode': 493
}
]
},
'systemd': {
'units': [
{
'contents': '[Unit]\nDescription=A hello world\n[Install]\nWantedBy=multi-user.target\n',
'enabled': true,
'name': 'hello.service'
},
{
'dropins': [
{
'contents': '[Service]\nEnvironment=LOG_LEVEL=trace\n',
'name': 'log_trace.conf'
}
],
'name': 'fdo-client-linuxapp.service'
}
]
}
}
----
+
After you run the \&#96;Butane Config YAML\&#96; file to check and generate the
\&#96;Ignition Config JSON\&#96; file, you might get warnings when using unsupported
fields, like partitions, for example. You can fix those fields and rerun
the check.

You have now an Ignition JSON configuration file that you can use to customize
your installation.

.Additional resources
\&#42; link:https://coreos.github.io/butane/config-fiot-v1_0/[Fedora IOT Specification v1.0.0].



= User Guide

Welcome to the user guide for Fedora IoT.
Both this guide and Fedora IoT images are in the very early stages, so please report any issues to https://lists.fedoraproject.org/admin/lists/iot.lists.fedoraproject.org/[the mailing list].

image::iot-fedora.svg[SoC board]

== Supported Platforms

Fedora IoT supports the x86_64 and aarch64 architectures.

We have a page covering the currently tested xref:reference-platforms.adoc[Reference Platforms].
Other devices supported by Fedora on x86_64, aarch64 or ARMv7 should work just fine but haven't been widely tested in the IoT context so your milage may vary.

The list of supported reference devices will expand with time.
If you're a hardware vendor and would like to have a device become a reference platform by actively participating and testing Fedora IoT,
please reach out to https://fedoraproject.org/wiki/User:Pbrobinson[Peter Robinson], the Fedora IoT Lead.

== Required resources

The images being created are currently 4GB in size.
The current memory used for testing is 1GB of RAM.
The Fedora IoT base image should run with less,
but of course this limits the amount of container applications can be run on top of the base OS.


= Updates and Rollbacks

NOTE: The latest image builds are available https://download.fedoraproject.org/pub/alt/iot/[here].

== Upgrade to the Latest Image
Display the status of the currently running deployment:

----
$ rpm-ostree status
----

The \&#96;rpm-ostree\&#96; command is used to manage the atomic system tree used by the Fedora IoT images. The \&#96;update\&#96; command is an alias for the \&#96;upgrade\&#96; command.

View the options with:

----
$ rpm-ostree upgrade --help
Usage:
rpm-ostree upgrade [OPTION…]

Perform a system upgrade

Help Options:
-h, --help                      Show help options

Application Options:
--os=OSNAME                     Operate on provided OSNAME
-r, --reboot                    Initiate a reboot after operation is complete
--allow-downgrade               Permit deployment of chronologically older trees
--preview                       Just preview package differences
--check                         Just check if an upgrade is available
-C, --cache-only                Do not download latest ostree and RPM data
--download-only                 Just download latest ostree and RPM data, don't deploy
--upgrade-unchanged-exit-77     If no upgrade is available, exit 77
--sysroot=SYSROOT               Use system root SYSROOT (default: /)
--peer                          Force a peer-to-peer connection instead of using the system message bus
--install=PKG                   Overlay additional package
--uninstall=PKG                 Remove overlayed additional package
--version                       Print version information and exit
----

Check for available updates:

----
$ sudo rpm-ostree upgrade --check
Receiving metadata objects: 0/(estimating) -/s 0 bytes\&#8230; done
AvailableUpdate:
Version: 29.20190211.0 (2019-02-11T13:18:27Z)
Commit: 5eb0553c02a8035a02f030c7fb8d5c6727d1ecb2700dade4b767363acfcab8e4
GPGSignature: Valid signature by C2A3FA9DC67F68B98BB543F47BB90722DBBDCF7C
Diff: 25 upgraded
----

Preview the package differences:

----
$ sudo rpm-ostree upgrade --preview
----

If you wish, you can download the packages only and not deploy them with:

----
$ sudo rpm-ostree upgrade --download-only
----

To apply the OSTree update deltas available on CDN use the following command:

----
$ sudo rpm-ostree upgrade
----

Due to the atomic nature of the OS, you will have to reboot into the new image to have the updates take effect:

----
$ systemctl reboot
----

== Rollback to a previous tree

The \&#96;rpm-ostree\&#96; utility keeps two deployments available.
Both have an entry in the bootloader menu.
The new updated entry with be the default.
If necessary, you can choose the other entry to boot into the previous deployment.

TIP: The timeout for GRUB2 to display the menu is very short at only one second. Pressing the space bar or an arrow key when the menu appears will interrupt the timeout and allow you to choose another entry. The ENTER key will boot the selected image.

To permanently switch back to the previous deployment:

----
$ sudo rpm-ostree rollback
----

Like with the upgrade, a system reboot will be required. You can use the \&#96;systemctl reboot\&#96; command or you can include the \&#96;--reboot\&#96; option when you issue the rollback command:

----
$ sudo rpm-ostree rollback --reboot
----

NOTE: More information about https://docs.fedoraproject.org/en-US/quick-docs/bootloading-with-grub2/[Bootloading with GRUB2] can be found in the Fedora Quick Docs.

NOTE: More information about the \&#96;rpm-ostree\&#96; command can be found in the upstream https://coreos.github.io/rpm-ostree/administrator-handbook/[Administrator Handbook]


== Automatic updates

A \&#96;rpm-ostreed\&#96; service is available to monitor for upgrades automatically.

To enable automated updates edit the \&#96;/etc/rpm-ostreed.conf\&#96; file. The options
available are as follow:

\&#42; The 'none' option disables automatic updates. This is the default policy.
\&#42; The 'check' option downloads enough metadata to display available updates with \&#96;rpm-ostree status\&#96;.
\&#42; The 'stage' option downloads, unpacks and stages the update which will be finalized on a reboot.
\&#42; The 'apply' option is the same as stage but also initiates the reboot to the new version.

----
\&#35; cat /etc/rpm-ostreed.conf
\&#35; Entries in this file show the compile time defaults.
\&#35; You can change settings by editing this file.
\&#35; For option meanings, see rpm-ostreed.conf(5).

[Daemon]
AutomaticUpdatePolicy=check
\&#35;IdleExitTimeout=60
----

Next we need to enable the appropriate services:
----
systemctl reload rpm-ostreed
systemctl enable rpm-ostreed-automatic.timer --now
----

We should now be able to see the state of automatic updates in the status:
----
\&#35; rpm-ostree status
State: idle
AutomaticUpdates: stage; rpm-ostreed-automatic.timer: last run 4min 22s ago
----

The rpm-ostreed-automatic.service and rpm-ostreed-automatic.timer control frequency of checks and upgrades.
More information is available in the man pages or this https://miabbott.github.io/2018/06/13/rpm-ostree-automatic-updates.html[blog post]



= Layered Packages

The Fedora IoT images utilize \&#96;rpm-ostree\&#96; which is a hybrid image/package system.
This allows layering a package on an existing image which produces a new versioned deployment.
Similarly, removing a layered package creates a new versioned image.
The rpm-ostree utility keeps two deployments available so a rollback procedure can be used to revert to a previous deployment.

Display the status of the currently running deployment:

----
$ rpm-ostree status
State: idle
AutomaticUpdates: disabled
Deployments:
● ostree://fedora-iot:fedora/stable/x86_64/iot  \&lt;1\&gt;
Version: 29.20190214.0 (2019-02-14T18:11:32Z)
BaseCommit: 007f24873c04fea4ee96024f6ebb6e56a29f634ab2a9e9218b15444666dd719c
GPGSignature: Valid signature by C2A3FA9DC67F68B98BB543F47BB90722DBBDCF7C
LayeredPackages: asciiquarium git  \&lt;2\&gt;

ostree://fedora-iot:fedora/stable/x86_64/iot  \&lt;3\&gt;
Version: 29.20190214.0 (2019-02-14T18:11:32Z)
Commit: 007f24873c04fea4ee96024f6ebb6e56a29f634ab2a9e9218b15444666dd719c
GPGSignature: Valid signature by C2A3FA9DC67F68B98BB543F47BB90722DBBDCF7C
----

\&lt;1\&gt; The currently running deployment is marked with a ●.
\&lt;2\&gt; The layered packages are listed in the description.
\&lt;3\&gt; The previous deployment is also available in the boot menu or for a rollback procedure.





= Adding Layered Packages

Add a layered package with the \&#96;rpm-ostree install\&#96; command:

----
$ rpm-ostree install --help
Usage:
rpm-ostree install [OPTION…] PACKAGE [PACKAGE\&#8230;]

Overlay additional packages

Help Options:
-h, --help              Show help options

Application Options:
--uninstall=PKG         Remove overlayed additional package
-C, --cache-only        Do not download latest ostree and RPM data
--download-only         Just download latest ostree and RPM data, don't deploy
--os=OSNAME             Operate on provided OSNAME
-r, --reboot            Initiate a reboot after operation is complete
-n, --dry-run           Exit after printing the transaction
--allow-inactive        Allow inactive package requests
--idempotent            Do nothing if package already (un)installed
--unchanged-exit-77     If no overlays were changed, exit 77
--sysroot=SYSROOT       Use system root SYSROOT (default: /)
--peer                  Force a peer-to-peer connection instead of using the system message bus
--version               Print version information and exit
----

== Install multiple packages

This command accepts multiple package names.
To create less images, consider grouping compatable packages into a single command.
This will create a single new layered image.

----
$ sudo rpm-ostree install git asciiquarium
----

Alternately, consider xref:container-support.adoc[using containers] for your applications.
A container workflow can be managed separately from the OS update cycle.

== Be sure to Reboot

At this point a new layer is available but not yet active.
For example, the git command installed above is not yet found.

----
$ git --version
bash: git: command not found
----

Display the current status of the images:

----
$ rpm-ostree status
State: idle
AutomaticUpdates: disabled
Deployments:
ostree://fedora-iot:fedora/stable/x86_64/iot
Version: 29.20190214.0 (2019-02-14T18:11:32Z)
BaseCommit: 007f24873c04fea4ee96024f6ebb6e56a29f634ab2a9e9218b15444666dd719c
GPGSignature: Valid signature by C2A3FA9DC67F68B98BB543F47BB90722DBBDCF7C
LayeredPackages: asciiquarium git \&lt;1\&gt;

● ostree://fedora-iot:fedora/stable/x86_64/iot  \&lt;2\&gt;
Version: 29.20190214.0 (2019-02-14T18:11:32Z)
Commit: 007f24873c04fea4ee96024f6ebb6e56a29f634ab2a9e9218b15444666dd719c
GPGSignature: Valid signature by C2A3FA9DC67F68B98BB543F47BB90722DBBDCF7C

ostree://fedora-iot:fedora/29/x86_64/iot  \&lt;3\&gt;
Version: 29.20181128.1 (2018-11-28T09:16:42Z)
Commit: f40b0a24b9c11ee859d4cb323222d0b979873d8d11f63fcb848cba6ab8a2515e
GPGSignature: Can't check signature: public key A20AA56B429476B4 not found
----

\&lt;1\&gt; The new image indicates layered packages.
\&lt;2\&gt; The second image listed is the active image as indicated by the ●.
\&lt;3\&gt; Any older images will be removed when the system is rebooted.


Due to the atomic nature of the OS, you will have to reboot into the new image to have the layered image take effect:

----
$ sudo systemctl reboot
----

Display the status of the images:

----
$ rpm-ostree status
State: idle
AutomaticUpdates: disabled
Deployments:
● ostree://fedora-iot:fedora/stable/x86_64/iot
Version: 29.20190214.0 (2019-02-14T18:11:32Z)
BaseCommit: 007f24873c04fea4ee96024f6ebb6e56a29f634ab2a9e9218b15444666dd719c
GPGSignature: Valid signature by C2A3FA9DC67F68B98BB543F47BB90722DBBDCF7C
LayeredPackages: asciiquarium git

ostree://fedora-iot:fedora/stable/x86_64/iot
Version: 29.20190214.0 (2019-02-14T18:11:32Z)
Commit: 007f24873c04fea4ee96024f6ebb6e56a29f634ab2a9e9218b15444666dd719c
GPGSignature: Valid signature by C2A3FA9DC67F68B98BB543F47BB90722DBBDCF7C
----

After the reboot, the git command will be available:

----
$ git --version
git version 2.20.1
----



= Removing Layered Packages

== Revert All Changes with a Rollback

If the entire image needs to be reverted to a pristine or known state, you can rollback to the previous version.

----
$ sudo rpm-ostree rollback --reboot
----

== Remove Select Layered Packages

The \&#96;rpm-ostree\&#96; utility also has an uninstall option to remove individual layered packages:

----
$ rpm-ostree uninstall --help
Usage:
rpm-ostree uninstall [OPTION…] PACKAGE [PACKAGE\&#8230;]

Remove overlayed additional packages

Help Options:
-h, --help              Show help options

Application Options:
--install=PKG           Overlay additional package
--all                   Remove all overlayed additional packages
--os=OSNAME             Operate on provided OSNAME
-r, --reboot            Initiate a reboot after operation is complete
-n, --dry-run           Exit after printing the transaction
--allow-inactive        Allow inactive package requests
--idempotent            Do nothing if package already (un)installed
--unchanged-exit-77     If no overlays were changed, exit 77
--sysroot=SYSROOT       Use system root SYSROOT (default: /)
--peer                  Force a peer-to-peer connection instead of using the system message bus
--version               Print version information and exit
----

Like the install or rollback, a system reboot will be required to activate the new image.



= Configuring Package Repositories

The \&#96;rpm-ostree\&#96; utility uses repositories configured in the \&#96;/etc/yum.repos.d\&#96; directory.

// the rpm-ostree utility does not include a --enablerepo options like dnf
To enable a specific repository, edit the configuration files in /etc/yum.repos.d and for each desired repository, change the enabled= line to \&#96;enabled=1\&#96;

You can add additional repository configuration files to enable third party or local package repositories.

Some repositories provide an RPM package to assist in the configuration.
For example, to enable the RPM Fusion Free repository you can use:

----
$ sudo rpm-ostree install https://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm
----

This method of configuration will require a reboot to enable the new image.

----
$ rpm-ostree status
State: idle
AutomaticUpdates: check; rpm-ostreed-automatic.timer: no runs since boot
Deployments:
● ostree://fedora-iot:fedora/stable/aarch64/iot
Version: 29.20190214.0 (2019-02-14T18:18:52Z)
BaseCommit: 68b1f6c99a678f45e3de04f1252b271cce687a246c0004e45858b343d3637556
GPGSignature: Valid signature by C2A3FA9DC67F68B98BB543F47BB90722DBBDCF7C
LayeredPackages: git
LocalPackages: rpmfusion-free-release-29-1.noarch \&lt;1\&gt;
----
\&lt;1\&gt; The package installed from a URL instead of a configured repository will appear with 'LocalPackages'

Additional resources:

\&#42; Fedora Quick Docs includes a description of https://docs.fedoraproject.org/en-US/quick-docs/repositories/[Fedora Repositories].
\&#42; Fedora Quick Docs describes third party repositories for https://docs.fedoraproject.org/en-US/quick-docs/assembly_installing-plugins-for-playing-movies-and-music/[Installing plugins for playing movies and music]. Replace the \&#96;dnf install\&#96; commands with \&#96;rpm-ostree install\&#96; for enabling on Fedora IoT images.
\&#42; The https://linux.die.net/man/5/yum.conf[yum.conf(5)] man page describes options for creating your own file in the [repository] OPTIONS section.




= Container Support

Fedora IoT has excellent support for container-focused workflows.
Containers provide for separation of OS updates from application updates, as well as allow testing and deployment of  different versions of applications.
Fedora IoT uses podman, a daemonless container engine to develop, download, manage, and run containers to support your home assistant, industrial gateways, or data storage and analytics.

With \&#96;podman\&#96;, images and containers can be managed and used by a non-privileged user.
Commands are very similar to those used with \&#96;docker\&#96;.

Show the version of podman and other configuration settings:

----
$ podman info
----

Run as a user, the storage location is under the \&#96;~/.local/share/containers\&#96; directory.
You can customize podman with files in the  \&#96;~/.config/containers\&#96; directory.
// storage.conf is one. verify which config file or dir is needed.

Run as root, the storage location is defined in the '/etc/containers/storage.conf' file and defaults to '/var/run/containers/storage'.

----
$ sudo podman info
----

Any of the \&#96;podman\&#96; commands have help available for several levels of commands.

Show all the commands available:

----
$ podman --help
----

Show the options for the pull command:

----
$ podman pull --help
----

Some commands have other sub commands.
Show the options for the image command:

----
$ podman image --help
----

To show more specific options, keep adding commands before the help request.
Show the options for listing images:

----
$ podman image ls --help
----

https://podman.io/[Podman] has a lot of well written documentation and articles.
You can find a number of them at the following links:


\&#42; https://github.com/projectatomic/libpod/blob/master/docs/tutorials/podman_tutorial.md[getting started tutorial]
\&#42; https://github.com/projectatomic/libpod/blob/master/transfer.md[docker to podman command mapping]
\&#42; https://medium.com/cri-o[Podman news and releases]


= Images and Containers

== Finding Images

Search for images with a keyword:

----
$ podman search fedora
$ podman search homeassistant
----

The registries which will be searched are configured in the /etc/containers/registry.conf file.

The search result will include both the registry location and the name of the image.

\&#42; The registry name may include a port number.
\&#42; The image name consists of USER/REPO. The user can be an individual, team, or company that uploads the images to the registry.
\&#42; The image repository contains tagged images and hidden layers. Most repositories contain an image with the tag of 'latest'.
\&#42; When downloading an image with pull, run, or build commands, you may specify a specific tag image. The default is to pull the image tagged 'latest'.

// Add reminder on naming conventions.

The https://github.com/containers/skopeo[\&#96;skopeo\&#96;] command is a utility to work with images in many different container environments.
It was created to view information in remote registries and is now a command and library for copying images with different transports.
It is used to manage container images and image storage remotely and locally and all without requiring root.
It can also pass authentication credentials when required by the repository.
// Source post: https://www.quora.com/What-is-skopeo-and-why-it-is-used-in-containers/answer/Daniel-Walsh-156

View creation dates, architectures, labels, tags, and layer checksums of a remote image repository:

----
$ skopeo inspect docker://registry.fedoraproject.org/fedora-minimal
----

== Manage Local Images

When you run a container, the image is first downloaded to the local system.
It can be helpful to go ahead and download an image as a separate command.

The default is to pull the latest image from the default registry:

----
$ podman pull fedora
----

You can also specify the registry, user, tag, or, as in the following example, some combination:

----
$ podman pull registry.fedoraproject.org/fedora-minimal:rawhide
----

List the local images:

----
$ podman images
REPOSITORY                                           TAG       IMAGE ID       CREATED       SIZE
registry.fedoraproject.org/fedora-minimal            rawhide   8ecda3b9bc0d   2 days ago    164MB
docker.io/homeassistant/raspberrypi3-homeassistant   latest    3c74046ca2a7   3 days ago    1.05GB
docker.io/library/fedora                             latest    8b38e3af7237   4 weeks ago   315MB
----

The same output is show with \&#96;podman image ls\&#96;.
Note the singular 'image' command before the additional 'ls' command.
If you have a lot of images, you may want to specify filters or sort by a value other than the creation date.

As a user, the local images will be stored under the \&#96;~/.local/share/containers/\&#96; directory.
Each user has their own namespace so these are separate from containers run as root.
Listing the images available to root displays a different or empty list:

----
$ sudo podman images
----

Some actions can not be done with rootless containers.
Some devices and volumes will require that you pull and run containers in the root namespace.
The current podman v1.0 also requires root for port publishing.
The next version will allow rootless port publishing.

Like remote images, local images can also be inspected:

----
$ podman inspect fedora
----

To inspect an image with a tag other than 'latest', include the tag:

----
$ podman inspect fedora-minimal:rawhide
----

== Running Containers

To launch the container use:

----
$ podman run fedora
----

With the fedora image, the container will start and then it exits since there is nothing left running. Some images are configured to run an application in the foreground and the container will not terminate until the application terminates.

To list the running containers use:

----
$ podman container ls
----

To see all containers, including those that have exited:

----
$ podman container ls -a
CONTAINER ID   IMAGE                             COMMAND     CREATED              STATUS                      PORTS   NAMES            IS INFRA
7835aaadd2d1   docker.io/library/fedora:latest   /bin/bash   About a minute ago   Exited (0) 14 seconds ago           hopeful_beaver   false
----

The exited containers are kept so that any data, including logs, can be investigated before they are lost. You can start an exited container but a typical workflow normally deletes used containers, launching new containers when needed.

Options on the run command can change the behavior of launching a container:

----
$ podman run -it \ \&lt;1\&gt;
\&gt; --name demo \ \&lt;2\&gt;
\&gt; --rm \ \&lt;3\&gt;
\&gt; fedora /bin/bash \&lt;4\&gt;
bash-4.4\&#35;  \&lt;5\&gt;
----
\&lt;1\&gt; The -it options enable interactive mode and allocates a pseudo-TTY.
\&lt;2\&gt; You can name your container. Without this option, a random name will be generated.
\&lt;3\&gt; The --rm option causes the container to be deleted when it is terminated. This preserves space and allows a new container to be started with the same name.
\&lt;4\&gt; The command to run. The command must be in the image. Not all images include bash.
\&lt;5\&gt; The /bin/bash process is running in the foreground. When you exit the shell, the container will terminate.

== Publishing Ports

If your application listens on the network, you will need to map the container port to a local port on your device.
In the current version, publishing ports requires root so the image must be available in the root namespace.

Add the \&#96;-p\&#96; option when you launch the container:

----
$ sudo podman run -p 127.0.0.1:8080:80 --name demo mydemohttp:latest
----

You can then connect to your application via 127.0.0.1:8080

The format is \&#96;ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort | containerPort\&#96;.

Other options for publishing ports and many other run options are available and well documented in the podman-run man page.

== Mapping a local directory

You may want to have your application write logs or collect data to a directory on the host.
Some containers expect that customized configuration files are on the host device.
In both cases, you can create a bind mount with the \&#96;--volume\&#96; option.
Specify the host directory, the mount point inside the container, and any mount options.

For example, https://www.home-assistant.io/docs/installation/docker/[Home Assistant] expects the configuration files to be on the host device:

----
$ podman run -d --name='home-assistant' -v /home/pi/homeassistant:/config -v /etc/localtime:/etc/localtime:ro --net=host homeassistant/raspberrypi3-homeassistant
----

== Mapping a local device

The \&#96;--device\&#96; option will add a host device to the container.
Specify the host device name and optionally, the device name on the container and any permissions.
Some devices, like the GPIO device, will require root.

To access the host GPIO device from the container:

----
$ sudo podman run -it --rm --name demo-gpio --device=/dev/gpiochip0 fedora:latest /bin/bash
----

== Connect to a Running Container

You can also connect to a running container. Specify the container name or ID and the command to execute:

----
$ podman exec -it demo /bin/bash
----

You can also view container logs directly with podman:

----
$ podman logs demo
----

Both the \&#96;exec\&#96; and \&#96;logs\&#96; commands are also part of the \&#96;podman container\&#96; command.

== Removing Containers and Images

List the containers to see the 'Container ID' and 'name' of each container.
Remove a container by specifying either the container ID or name:

----
$ podman container rm demo
----

Removing a container happens automatically when a container terminates if the container was started with the \&#96;--rm\&#96; option.

Removing a container does not remove the image.
List the local images with \&#96;podman images\&#96; or \&#96;podman image ls\&#96;.
Remove the image using either the 'IMAGE ID' or the repository name and tag:

----
$ podman rmi registry.fedoraproject.org/fedora-minimal:rawhide
----

You can also remove an image with the \&#96;image\&#96; command:

----
$ podman image rm registry.fedoraproject.org/fedora-minimal:rawhide
----


= Build a Container with a Containerfile

== Creating the Containerfile
If a container does not already exist for your application, one can be built for your device.

It is common to create images from a working directory which holds the Containerfile and any supporting files. This may be a version controlled directory to facilitate sharing.

----
$ mkdir container-demo \&amp;\&amp; cd container-demo
----

There are many examples of building containers using a Containerfile.
A simple Containerfile will contain some of the following elements:

\&#42; The FROM line indicates the base, or starting, container, such as a latest Fedora image.
This image will be pulled if it is not already available locally.
Specify details for which image the same as you would with a \&#96;podman pull\&#96; command.
\&#42; Creates layers with each RUN command.
Try to minimize the number of layers with multiple commands on the same line using \&amp;\&amp; between commands.
Also include any cleanup commands such as \&#96;dnf clean all\&#96; to reduce the final image size.
\&#42; Copy content from the working directory into the container.
\&#42; Specify any ports to listen on with EXPOSE
\&#42; Start your application
\&#42;\&#42; CMD can be over written with podman run command
\&#42;\&#42; ENTRYPOINT often base command and default options. Can be coupled with CMD for additional options.

== Example: Web application

Create a working directory with some content for a web server:

----
$ mkdir demo-httpd \&amp;\&amp; cd demo-httpd \&amp;\&amp; echo 'sample container' \&gt; index.html
----

Start the Containerfile with a FROM command to indicate the base image:

----
$ echo 'FROM fedora:latest' \&gt;\&gt; Containerfile
----

Add a RUN command to update the image and add any application and utilities:

----
$ echo 'RUN dnf -y update \&amp;\&amp; dnf -y install httpd git  \&amp;\&amp; dnf clean all' \&gt;\&gt; Containerfile
----

The above example installs git.
If your web content is hosted in a version control system, you can add a RUN statement to clone that data to the container.
If your content is available in the build working directory, you can use the COPY command to add it to the container.

Copy to the sample index.html file into the container:

----
$ echo 'COPY index.html /var/www/html/index.html' \&gt;\&gt; Containerfile
----

The EXPOSE line specifies that the container listens on specified network ports.
It is used by the \&#96;--publish-all\&#96; option on the \&#96;podman run\&#96; command.

Document what ports are available to publish:

----
$ echo 'EXPOSE 80' \&gt;\&gt; Containerfile
----

Specify the command to run when the container starts:

----
$ echo 'ENTRYPOINT /usr/sbin/httpd -DFOREGROUND' \&gt;\&gt; Containerfile
----

NOTE: Port bindings are not yet supported by rootless containers.
If your container needs to be available on the network, build it in the root namespace.
Port bindings for rootless containers is available in upstream testing for podman 1.1.0 with slirp4netns v0.3.0.
// https://github.com/containers/libpod/issues/2081

Build the image with a descriptive tag:

----
$ sudo podman build --tag fedora:myhttpd -f ./Containerfile
----

The image will appear in the local registry:

----
$ sudo podman images
REPOSITORY                 TAG       IMAGE ID       CREATED         SIZE
localhost/fedora           myhttpd   223534b48a9c   3 minutes ago   474MB
docker.io/library/fedora   latest    8b38e3af7237   4 weeks ago     315MB
----

To make the application port available to the host device use the \&#96;--publish\&#96; or \&#96;-p\&#96; option with \&#96;hostPort:containerPort\&#96; numbers.
An IP can also be specified as well as ranges of ports. See the https://github.com/containers/libpod/blob/master/docs/source/markdown/podman-run.1.md[man page] for more options.

Run the container and publish the port:

----
$ sudo podman run -p 8080:80 --name myhttpd --rm fedora:myhttpd
----

View the port information:

----
$ sudo podman port myhttpd
80/tcp -\&gt; 0.0.0.0:8080
----

Access the web page from the host device:

----
$ curl localhost:8080
----

Access the web page from a remote location using the IP address of the host device and the published port number.

Open firewall ports, services, or sources as needed.
The Fedora IoT image defaults to allowing any source on the same network through the interfaces option:

----
$ sudo firewall-cmd --list-all
public (active)
target: default
icmp-block-inversion: no
interfaces: eth0
sources:
services: dhcpv6-client mdns ssh
ports:
protocols:
masquerade: no
forward-ports:
source-ports:
icmp-blocks:
rich rules:
----

Add a port with:

----
$ sudo firewall-cmd --add-port 8080/tcp
----

More information on the \&#96;firewall-cmd\&#96; command can be found at https://firewalld.org/documentation/man-pages/firewall-cmd.html[firewalld.org].

== Example: Interaction with GPIO interface

To interact with the GPIO interface, layer the \&#96;libgpiod-utils\&#96; package on the existing image or use with a container.

To layer the package:

----
$ sudo rpm-ostree install libgpiod-utils python3-libgpiod
$ sudo gpiodetect
----

To create a container for an application that works with the GPIO interface in the root namespace.

Start the Containerfile with a FROM command to indicate the base image:

----
$ echo 'FROM fedora:latest' \&gt;\&gt; Containerfile
----

Add a RUN command to update the image and add any application and utilities:

----
$ echo 'RUN dnf -y update \&amp;\&amp; dnf -y install git libgpiod-utils python3-libgpiod \&amp;\&amp; dnf clean all' \&gt;\&gt; Containerfile
----

The fedora:latest image includes bash so we can go ahead and build the container without any specific applications to start or ports to expose. The command can be specified when we run the container.

Build the image with a descriptive tag:

----
$ sudo podman build --tag fedora:gpio -f ./Containerfile
----

The image will appear in the localhost registry for the root namespace:

----
$ sudo podman images
REPOSITORY                 TAG      IMAGE ID       CREATED         SIZE
localhost/fedora           gpio     655abf78e6b9   4 minutes ago   542MB
docker.io/library/fedora   latest   8b38e3af7237   4 weeks ago     315MB
----

To access the host GPIO device from the container, use the \&#96;--device\&#96; option when you start the container:

----
$ sudo podman run -it --name demo-gpio --device=/dev/gpiochip0 localhost/fedora:gpio /bin/bash
----

Verify you can see the GPIO device:

----
[root@167f31750fdb /]\&#35; gpiodetect
gpiochip0 [pinctrl-bcm2835] (54 lines)
----

Now that the device is available from the container, continue to use the installed tools or add addition applications.

Examples for using \&#96;gpioset\&#96; can be found in a 2018 Fedora Magazine article:
https://fedoramagazine.org/turnon-led-fedora-iot/[How to turn on an LED with Fedora IoT]

Automate additional steps by modifying the Containerfile and building a new container.

The images do not have to be built from a Fedora container.
This Containerfile uses a raspbian image and clones the http://lightshowpi.org/[lightshowpi] project:

----
$ cat Containerfile
FROM raspbian/stretch:latest
RUN apt-get -y update \&amp;\&amp; apt-get -y install git-core \&amp;\&amp; apt-get -y clean
WORKDIR /
RUN git clone https://togiles@bitbucket.org/togiles/lightshowpi.git \&amp;\&amp; \
cd lightshowpi \&amp;\&amp; git fetch \&amp;\&amp; git checkout stable
----

The Docker documentation includes https://docs.docker.com/develop/develop-images/dockerfile_best-practices/[Containerfile best practices].

== Reusing and Sharing the Containers

Once the container image is created it can be deployed to multiple devices by uploading it to a registry.

Most registries require a naming convention of the 'useraccount/description:tag' and the default for most pull commands is to look for a container with a tag of 'latest'.
An image can have multiple tags and these tags are used to help identify architecture compatibility and version control.

To rename or add a tag to a local image:

----
$ podman tag fedora:myhttpd testuser/fedora-myhttpd:latest
$ podman tag fedora:myhttpd quay.io/testuser/fedora-myhttpd:latest
----

Both names will appear in the list of images but the image ID will be the same for each:

----
$ podman images
REPOSITORY                               TAG       IMAGE ID       CREATED        SIZE
localhost/fedora                         myhttpd   d52cbe4136e8   24 hours ago   428 MB
localhost/testuser/fedora-myhttpd        latest    d52cbe4136e8   24 hours ago   428 MB
quay.io/testuser/fedora-myhttpd          latest    d52cbe4136e8   24 hours ago   428 MB
docker.io/library/fedora                 latest    26ffec5b4a8a   4 weeks ago    283 MB
----

You can then push an image to a registry with \&#96;podman push imageID destination\&#96;.

To extract the image to a local directory in a docker format:

----
$ podman push quay.io/testuser/fedora-myhttpd dir:/tmp/fedora-myhttpd
----

For more exporting options, see the https://github.com/containers/libpod/blob/main/docs/source/markdown/podman-push.1.md[podman-push] man page.



= Build a Container with Buildah

Buildah is a tool that facilitates building OCI container images.
You can build images from scratch, from a container pulled from a registry, or using a Dockerfile.

To use buildah in the Fedora IoT you will need to install the layered packages:

----
$ sudo rpm-ostree install buildah
----

More commonly buildah is used in a developer environment and the resulting containers are then uploaded to a registry for use on any device.

The commands for building a container from a base image are similar to the lines in a Dockerfile. The first step is to pull the base images and create the working container:

----
$ buildah from fedora
fedora-working-container
----

Add packages to the working container:

----
$ buildah run fedora-working-container dnf install httpd -y
----

Create a working directory with some content for a web server:

----
$ mkdir demo-httpd \&amp;\&amp; cd demo-httpd \&amp;\&amp; echo 'sample container' \&gt; index.html
----


Copy local files into the working container:

----
$ buildah copy fedora-working-container index.html /var/www/html/index.html
----

Define the container entrypoint to start the application:

----
$ buildah config --entrypoint '/usr/sbin/httpd -DFOREGROUND' fedora-working-container
----

Once configured, save the image:

----
$ buildah commit fedora-working-container fedora-myhttpd
----

You can list the local images:

----
$ buildah images
----

The buildah images are the same as the podman images.
You can run now the container locally with podman:

----
$ podman run fedora-myhttpd
----

To make the image available on other devices, push the image to a registry.
The default image has a tag of 'latest'.
Use \&#96;buildah tag\&#96; to add additional tags to the image before pushing to a repository.

To push the image to a local Docker registry:

----
$ buildah push --tls-verify=false fedora-myhttpd docker://localhost:5000/testuser/fedora-myhttpd:latest
----

To push to a remote registry provide the correct URL and any required credentials:

----
$ buildah push --creds testuser:5bbb9990-1234-1234-1234-aaa80066887c fedora-myhttpd docker://testuser/fedora-myhttpd
----

Skopeo can be used to inspect the results:

----
$ skopeo inspect --tls-verify=false docker://localhost:5000/testuser/fedora-myhttpd:latest
----

Test the portability of the container with \&#96;docker pull\&#96; or \&#96;podman pull\&#96; or \&#96;buildah from\&#96; commands.

Learn more about using buildah from:

\&#42; Fedora Magazine: https://fedoramagazine.org/daemon-less-container-management-buildah/[How to build container images with Buildah (2018)]
\&#42; buildah.io: https://github.com/containers/buildah/tree/master/docs/tutorials[Tutorials]


= Updating Packages and Applications

== Updating Layered Packages

Packages added to the Fedora IoT image with \&#96;rpm-ostree install\&#96; will be updated along with the base operating system when \&#96;rpm-ostree upgrade\&#96; is run as described in xref:applying-updates-UG.adoc[Updates and Rollbacks].

The \&#96;rpm-ostree\&#96; utility uses repositories configured in the /etc/yum.repos.d directory.
The Fedora IoT image is configured to check for packages from several Fedora repositories including the fedora-updates and fedora-updates-modular repositories.

In Fedora, before updates are generally available, they are tested in the fedora-updates-testing and fedora-updates-testing-modular repositories.
The configuration files and gpg keys for these repositories are included in the Fedora IoT image but are not enabled by default.

// the rpm-ostree utility does not include a --enablerepo options like dnf
To enable the testing repos, edit the configuration files in /etc/yum.repos.d and for each desired repository, change the enabled= line to \&#96;enabled=1\&#96;

----
$ cat /etc/yum.repos.d/fedora-updates-testing-modular.repo
[updates-testing-modular] \&lt;1\&gt;
name=Fedora Modular $releasever - $basearch - Test Updates
failovermethod=priority
\&#35;baseurl=http://download.fedoraproject.org/pub/fedora/linux/updates/testing/$releasever/Modular/$basearch/
metalink=https://mirrors.fedoraproject.org/metalink?repo=updates-testing-modular-f$releasever\&amp;arch=$basearch
enabled=1  \&lt;2\&gt;
repo_gpgcheck=0
type=rpm
gpgcheck=1
metadata_expire=6h
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-$releasever-$basearch
skip_if_unavailable=False

[updates-testing-modular-debuginfo]  \&lt;3\&gt;
name=Fedora Modular $releasever - $basearch - Test Updates Debug
failovermethod=priority

\&#8230; Output Truncated \&#8230;
----
\&lt;1\&gt; Each repository has a name in square brackets
\&lt;2\&gt; The enabled parameter takes a boolean value
\&lt;3\&gt; A configuration file can contain multiple repository configurations.

You can xref:add-repos.adoc[add additional repository] configuration files to enable other update, testing, or development repositories.

== Updating Containers

By placing applications in containers, the host operating system can be updated quickly without affecting package versions inside the container.
But what about when the fix needs to be applied to packages that are a part of the container?

Containers are supposed to be lightweight, interchangeable, and ephemeral.
When an container is in need of an update, it is removed and a new container is deployed in its place.

If your containers are built from another base image, you need to monitor that base image for updates and to rebuild your containers using the updated image.

The industry has a variety of services available to assist with vulnerability scanning, update notifications, build systems, and other CD/CI tools for containers.

It's a good practice to not patch inside of a container as it does not scale well.
Instead, build a new container and then deploy that container to many devices.
A container available in a shared registry and tagged as 'latest' will be used the next time podman run requests that image.


= Rebasing to New Versions

The \&#96;rpm-ostree rebase\&#96; command allows you to switch between multiple branches.
The \&#96;ostree remote\&#96; command allows you to view and change repository options.


== Listing Remote Repositories

The \&#96;ostree remote\&#96; command has several options:

----
$ ostree remote --help
Usage:
ostree remote [OPTION…] COMMAND

Remote commands that may involve internet access

Builtin 'remote' Commands:
add               Add a remote repository
delete            Delete a remote repository
show-url          Show remote repository URL
list              List remote repository names
gpg-import        Import GPG keys
add-cookie        Add a cookie to remote
delete-cookie     Remove one cookie from remote
list-cookies      Show remote repository cookies
refs              List remote refs
summary           Show remote summary

Help Options:
-h, --help        Show help options

Application Options:
-v, --verbose     Print debug information during command processing
--version         Print version information and exit
----

List remote repository names:

----
$ ostree remote list
fedora-iot
----

Show the remote URL:

----
$ ostree remote show-url fedora-iot
https://ostree.fedoraproject.org/iot
----

List the remote reference branches:

----
$ ostree remote refs fedora-iot
fedora-iot:fedora/stable/aarch64/iot
fedora-iot:fedora/stable/x86_64/iot
fedora-iot:fedora/devel/aarch64/iot
fedora-iot:fedora/devel/x86_64/iot
fedora-iot:fedora/rawhide/aarch64/iot
fedora-iot:fedora/rawhide/x86_64/iot
----

== Adding and Removing Remote Repositories

The ostree remote repository configuration files are located in the \&#96;/etc/ostree/remotes.d\&#96; directory.

----
$ cat /etc/ostree/remotes.d/fedora-iot.conf
[remote_'fedora-iot']
url=https://ostree.fedoraproject.org/iot
gpg-verify=true
gpgkeypath=/etc/pki/rpm-gpg/
contenturl=mirrorlist=https://ostree.fedoraproject.org/iot/mirrorlist
----

The first line specifies the name of the remote that will be shown with \&#96;ostree remote list\&#96;. The additional lines are in the format of 'KEY=VALUE'.

To add a remote repository use the \&#96;ostree remote add\&#96; command:

----
$ ostree remote add --help
Usage:
ostree remote add [OPTION…] NAME [metalink=|mirrorlist=]URL [BRANCH\&#8230;]

Add a remote repository

Help Options:
-h, --help                        Show help options

Application Options:
--set=KEY=VALUE                   Set config option KEY=VALUE for remote
--no-gpg-verify                   Disable GPG verification
--if-not-exists                   Do nothing if the provided remote exists
--gpg-import=FILE                 Import GPG key from FILE
--contenturl=URL                  Use URL when fetching content
--collection-id=COLLECTION-ID     Globally unique ID for this repository as an collection of refs for redistribution to other repositories
--repo=PATH                       Path to OSTree repository (defaults to /sysroot/ostree/repo)
--sysroot=PATH                    Use sysroot at PATH (overrides --repo)
-v, --verbose                     Print debug information during command processing
--version                         Print version information and exit
----

The \&#96;--set\&#96; option can be used multiple times to configure any KEY=VALUE pair. Some of the more common or required keys have their own options.
For example, the following two commands result in identical configuration files. They differ only in how the contenturl is specified:

----
$ sudo ostree remote add --set=contenturl=mirrorlist=https://ostree.fedoraproject.org/iot/mirrorlist --set=gpgkeypath=/etc/pki/rpm-gpg/ fedora-iot 'https://ostree.fedoraproject.org/iot'
----

----
$ sudo ostree remote add --contenturl=mirrorlist=https://ostree.fedoraproject.org/iot/mirrorlist --set=gpgkeypath=/etc/pki/rpm-gpg/ fedora-iot 'https://ostree.fedoraproject.org/iot'
----

To delete a remote repository use:

----
$ sudo ostree remote delete fedora-iot
----


== Moving between Build Trees

Currently there are three branches, the stable, develop, and rawhide branches. Each branch corresponds to the Fedora release that's the latest stable (stable), rawhide and if Fedora currently has a branched version that is undergoing stablisation in preparaiton for release (devel).

You need to specify the architecture as part of the branch option.
At the moment the options are aarch64 or x86_64.

To rebase to stable:

----
$ sudo rpm-ostree rebase -b fedora/stable/\&lt;ARCH\&gt;/iot
----

To rebase to devel:

----
$ sudo rpm-ostree rebase -b fedora/devel/\&lt;ARCH\&gt;/iot
----

To rebase to rawhide:

----
$ sudo rpm-ostree rebase -b fedora/rawhide/\&lt;ARCH\&gt;/iot
----

Once ready, reboot the system to use the new image:

----
$ sudo systemctl reboot
----

== Rebase to any New Version

Recent releases will automatically import the release keys in the specified directory if they are present on a rebase.

----
Usage:
ostree remote gpg-import [OPTIONS\&#8230;] NAME [KEY-ID\&#8230;]
----

Provide the reference path for the new version in the rebase command:

----
$ sudo rpm-ostree rebase VERSION
----

The process is very similar to a system update.
The new OS is downloaded and installed in the background.
Once ready, reboot the system to use the new image:

----
$ sudo systemctl reboot
----

Just like system updates, rebases can be reversed.
The previous deployment is still available, and you can boot back into it if there are any problems with the new OS.

NOTE: More information is available in the upstream documentation for https://ostree.readthedocs.io[libostree] and https://rpm-ostree.readthedocs.io[rpm-ostree].



= Administration Tasks

Additional tasks mimic any other Linux administration tasks and use available utilities included in the Fedora distribution.
Some tasks are described below with specific links to other Fedora Documentation or upstream documentation.

General Resources:

\&#42; https://docs.fedoraproject.org/en-US/quick-docs/[Fedora Quick Docs]
\&#42; Man pages

== User Management

The initial image includes a locked root account without a password, ssh keys can be added using xref:ignition-device-setup.adoc[ignition].

----
$ id testuser
uid=1000(testuser) gid=1000(testuser) groups=1000(testuser),10(wheel)
$ getent passwd testuser
testuser:x:1000:1000::/home/testuser:/bin/bash
----

Package installation may add additional users to own files and processes on the system.
For example the httpd package installation scripts will create a user apache if one does not already exist.

----
$ id apache
uid=48(apache) gid=48(apache) groups=48(apache)
$ getent passwd apache
apache:x:48:48:Apache:/usr/share/httpd:/sbin/nologin
----

This account is typically a system account with a UID below 1000, no password, and a shell of \&#96;/sbin/nologin\&#96;.
Accounts with a nologin shell cannot be used interactively.
These accounts also do not have a home directory created in \&#96;/home\&#96;

To manually create a system account for your application use the useradd command:

----
$ sudo useradd -r -s /sbin/nologin appuser
$ getent passwd appuser
appuser:x:992:981::/var/home/appuser:/sbin/nologin
----

Centralized users accounts (LDAP, Kerberos) can be configured with \&#96;authconfig\&#96; after the client packages, including \&#96;sssd\&#96;, have been installed.
The \&#96;/etc/nsswitch.conf\&#96; file is already configured to look for sss as well as files and altfiles for account information.

User accounts which are members of the wheel group automatically have full privileges with the \&#96;sudo\&#96; command.
This is from the following lines in the sudo configuration file:

----
$ sudo grep wheel /etc/sudoers
\&#35;\&#35; Allows people in group wheel to run all commands
%wheel	ALL=(ALL)	ALL
\&#35; %wheel	ALL=(ALL)	NOPASSWD: ALL
----

Edits to this configuration file should be made with the \&#96;visudo\&#96; command so that syntax is checked on exit.
Instead of editing the main configuration file, grant other users the ability to issue specific commands as a different user by adding a configuration file to the \&#96;/etc/sudoers.d/\&#96; directory.

\&#42; Fedora Quick Docs:
https://docs.fedoraproject.org/en-US/quick-docs/performing-administration-tasks-using-sudo/[Performing administration tasks using sudo]

Use \&#96;ssh-keygen\&#96; to generate an ssh key pair then add the public key to the user account on your Fedora IoT device:

----
$ ssh-copy-id testuser@10.11.12.13
----

Replace the username and IP address with that of your device.
Use the \&#96;-i\&#96; option to specify a key file other than the default of the most recently modified \&#96;~/.ssh/id_\&#42;pub\&#96; file.
The \&#96;ssh-copy-id\&#96; command will append the public key to the user's authorized keys file on the device. It will create the \&#96;~/.ssh\&#96; directory if it does not already exist and ensure the permission on the files are correct.

== Group Management

Due to how \&#96;rpm-ostree\&#96; handles user + group entries, it may not be possible to use \&#96;usermod -a -G\&#96; to add a user to a group successfully.
Until \&#96;rpm-ostree\&#96; moves to using \&#96;systemd sysusers\&#96;, users will have to populate the \&#96;/etc/group\&#96; file from the \&#96;/usr/lib/group\&#96; file before they can add themselves to the group.

For example, if you wanted to add a user to the \&#96;libvirt\&#96; group:

$ grep -E '^libvirt:' /usr/lib/group | sudo tee -a /etc/group
$ sudo usermod -aG libvirt $USER

NOTE: You will need to log off and log back in to apply these changes.

This issue is tracked in https://github.com/coreos/rpm-ostree/issues/29[rpm-ostree\&#35;29] and https://github.com/coreos/rpm-ostree/issues/49[rpm-ostree\&#35;49].

_(Text copied from the https://docs.fedoraproject.org/en-US/fedora-silverblue/troubleshooting/\&#35;_unable_to_add_user_to_group[Fedora Silverblue documentation])_

== Network Configuration

List the network devices:

----
$ nmcli dev
DEVICE  TYPE      STATE      CONNECTION
eth0    ethernet  connected  System eth0
lo      loopback  unmanaged  --
----

Show details of a device:

----
$ nmcli dev show eth0
GENERAL.DEVICE:                         eth0
GENERAL.TYPE:                           ethernet
GENERAL.HWADDR:                         B8:27:EB:B4:93:D8
GENERAL.MTU:                            1500
\&#8230;Output Omitted\&#8230;
----

List the connection configurations:

----
$ nmcli con
NAME         UUID                                  TYPE      DEVICE
System eth0  5fb06bd0-0bb0-7ffb-45f1-d6edd65f3e03  ethernet  eth0
enp1s0       8a6006ff-a1b5-4048-be93-258087a1853f  ethernet  --
----

Only one connection per device can be UP but multiple connections can be defined.

Show connection information:

----
$ nmcli con show enp1s0
connection.id:                          enp1s0
connection.uuid:                        8a6006ff-a1b5-4048-be93-258087a1853f
connection.stable-id:                   --
connection.type:                        802-3-ethernet
\&#8230; Output Omitted \&#8230;
----

The \&#96;nmcli conn\&#96; command has a variety of options including edit, modify, up, down, add, and delete.
Use the \&#96;nmcli conn help\&#96; command to view the syntax.

The default configurations will try to obtain connection information from a DHCP service on your network.
If no DHCP service is available on your network, you can add a static connection:

----
$ nmcli connection add con-name cable ipv4.addresses \
192.168.0.10/24 ipv4.gateway 192.168.0.1 \
connection.autoconnect true ipv4.dns '8.8.8.8,1.1.1.1' \
type ethernet ifname eth0 ipv4.method manual
----

Connect a device to a wifi SSID, prompting for the password:

----
$ sudo nmcli –ask device wifi connect SSID-Name
----

For more wifi options look at:

----
$ nmcli device wifi help
----

\&#42; Fedora Quick Docs:
https://docs.fedoraproject.org/en-US/quick-docs/configuring-ip-networking-with-nmcli/[Configuring ip networking with nmcli]

== Securing remote access

The root account is locked by default with no password set.
The SSH daemon is configured with password authentication disabled for the root account and only allows access remotely if an ssh key has been added.

Disable remote ssh access for root by editing the following line in the  \&#96;/etc/ssh/sshd_config\&#96; file:

----
PermitRootLogin no
----

To disable password authentication for all users, edit \&#96;/etc/ssh/sshd_config\&#96; file and add the following:

----
PasswordAuthentication no
----

View the default firewall configuration:

----
$ sudo firewall-cmd --list-all
----

The \&#96;firewalld\&#96; services are different than \&#96;systemd\&#96; services.
To see what configuration a \&#96;firewalld\&#96; service includes use:

----
$ sudo firewall-cmd --info-service=mdns
mdns
ports: 5353/udp
protocols:
source-ports:
modules:
destination: ipv4:224.0.0.251 ipv6:ff02::fb
----

Use the \&#96;--add-service\&#96; or \&#96;--add-port\&#96; options to open ports in the firewall:

----
$ sudo firewall-cmd --add-port=8080/tcp --add-port=8081/tcp --permanent
$ sudo firewall-cmd --reload
----

The \&#96;--permanent\&#96; option saves the setting to files so that they will be loaded the next time \&#96;firewalld\&#96; is loaded.
The \&#96;--reload\&#96; option reloads the configuration from the saved files.
If you add a port or service without the \&#96;--permanent\&#96; option, it will modify the runtime firewalld settings but it will not save your changes to survive a reboot of the system.

\&#42; Fedora Quick Docs:
https://docs.fedoraproject.org/en-US/quick-docs/firewalld/[Using firewalld]

== Service Management

Services are managed by \&#96;systemd\&#96; and they can be started and enabled with \&#96;systemctl\&#96;.

The Fedora IoT image boots to a multi-user target by default.
----
$ systemctl get-default
multi-user.target
----

A small number of services are enabled:

----
$ systemctl list-unit-files  --state enabled
----

Package installation does not usually start or enable a service:

----
$ systemctl status httpd
● httpd.service - The Apache HTTP Server
Loaded: loaded (/usr/lib/systemd/system/httpd.service; disabled; vendor preset: disabl\&gt;
Active: inactive (dead)
Docs: man:httpd.service(8)
----

The \&#96;--now\&#96; option allows you to start a service on the enable command:

----
$ sudo systemctl enable httpd --now
Created symlink /etc/systemd/system/multi-user.target.wants/httpd.service → /usr/lib/systemd/system/httpd.service.
----

\&#42; Fedora Quick Docs:
https://docs.fedoraproject.org/en-US/quick-docs/systemd-understanding-and-administering/[Understanding and administering systemd]

== Viewing Logs

Log files are generally located in the \&#96;/var/log\&#96; directory.
System logs can be viewed and searched with \&#96;journalctl\&#96;.

\&#42; Fedora Quick Docs:
https://docs.fedoraproject.org/en-US/quick-docs/viewing-logs/[Viewing logs in Fedora]

== Editing Kernel Command Line Arguments

Sometimes it's useful to be able to edit the kernel command line arguments, whether to add a serial console or some options for debugging.

View the current kernel command line:

----
$ sudo rpm-ostree kargs
----

Edit the kernel command line arguments with the default editor (the default for editor is vim) to adjust such as adding a serial console:

----
$ sudo rpm-ostree kargs --editor
----

Reboot the system:

----
$ sudo systemctl reboot
----

== Remote Administration with Ansible

The Fedora IoT image includes python3 and Ansible versions 2.5 and above have support for Python 3 (python 3.5 and above only).
To use Ansible to configure your Fedora IoT device, set the ansible_python_interpreter configuration option use the python3 binary \&#96;/usr/bin/python3\&#96;.
This is done with an inventory variable as described in the
https://docs.ansible.com/ansible/latest/reference_appendices/python_3_support.html[Ansible Python 3 Support^] documentation.

The https://docs.ansible.com/ansible/latest/user_guide/index.html[Ansible User Guide] covers how to work with Ansible.
Some useful https://docs.ansible.com/ansible/latest/user_guide/modules.html[modules] include:

\&#42; Networks: nmcli
\&#42; Users: user, authorized_key, htpasswd
\&#42; Packages, services and ports: yum_repository, service, firewalld
\&#42; Files and directories: file, copy, template, get_url, unarchive
\&#42; Interact with HTTP and HTTPS web services: uri
\&#42; System: timezone, reboot

There is a community supported module for rpm-ostree, https://docs.ansible.com/ansible/latest/collections/community/general/rpm_ostree_pkg_module.html\&#35;[community.general.rpm_ostree_pkg], which can be used to add and remove overlays.
You must install the community.general collection to use this module.

----
$ ansible-galaxy collection install community.general
----

Then the module can be used like so:

----
- name: install cockpit
community.general.rpm_ostree_pkg:
name:
- cockpit
- cockpit-podman
- cockpit-storaged
- cockpit-ostree
state: present
register: result

- name: reboot if new stuff was installed
reboot:
reboot_timeout: 300
when: result.changed

- name: start and enable cockpit
service:
name: cockpit.socket
state: started
enabled: true

- name: allow cockpit through firewall
firewalld:
service: cockpit
permanent: yes
immediate: yes
state: enabled
----


= Fedora IoT Bootc Images

As part of Fedora's initiative towards bootable containers, you can now create Fedora IoT \&#96;bootc\&#96; images. These images use standard
OCI/Docker containers as transport but contain all components needed to boot a Fedora IoT system. This allows you to ship updates to
your Fedora IoT system using container images.

\&#96;bootc\&#96; is part of the standard Fedora IoT distribution. After xref:physical-device-setup.adoc[setting up a Physical Device]
you can use the \&#96;bootc\&#96; tools to update the system.

Essentially, Fedora IoT \&#96;bootc\&#96; images retain all the functionality you're used to in Fedora IoT, while leveraging the flexibility
and ease of maintenance provided by \&#96;bootc\&#96;.

For more information, please check out the https://docs.fedoraproject.org/en-US/bootc/[official bootc documentation], as well as the
https://gitlab.com/fedora/bootc/base-images[Fedora Bootc Base Images Git repository].


= Fedora IoT Bootc Image Example with Podman Machine

This example walks through building and booting a Fedora IoT \&#96;bootc\&#96; image in a Podman machine.

NOTE: This example is based on the Fedora \&#96;bootc\&#96; documentation about building scratch images; reference the upstream docs
https://docs.fedoraproject.org/en-US/bootc/building-from-scratch/\&#35;_using_bootc_base_imagectl_build_rootfs[here] for the latest version/information.

To start, create a \&#96;Containerfile.custom\&#96; with the following contents:

[source,dockerfile]
----
FROM quay.io/fedora-testing/fedora-bootc:rawhide-standard as builder
RUN /usr/libexec/bootc-base-imagectl build-rootfs --manifest=fedora-iot /target-rootfs

FROM scratch
COPY --from=builder /target-rootfs/ /
LABEL containers.bootc 1
ENV container=oci
STOPSIGNAL SIGRTMIN+3
CMD ['/sbin/init']
----

Initialize your Podman machine using the following command. You may skip this step if you already have a Podman machine.

[source,bash]
----
podman machine init
----

Grant your Podman machine the permissions necessary to run your Fedora IoT \&#96;bootc\&#96; image using:

[source,bash]
----
podman machine set --rootful
----

Start your Podman machine using:

[source,bash]
----
podman machine start
----

Use the following command to build your \&#96;fedora-iot\&#96; image:

[source,bash]
----
podman -c podman-machine-default-root build --cap-add=all --security-opt=label=disable \
--device /dev/fuse -t localhost/fedora-iot -f Containerfile.custom .
----

After building the \&#96;localhost/fedora-iot\&#96; image, you should be able to see it in your Podman machine's list of images. Use the following command to check:

[source,bash]
----
podman -c podman-machine-default-root images
----

NOTE: The next step uses \&#96;podman-bootc\&#96;. If you need to install \&#96;podman-bootc\&#96;, please follow the instructions in the
https://github.com/containers/podman-bootc[podman-bootc repository]

You're now ready to boot a virtual machine using your new Fedora IoT \&#96;bootc\&#96; image. The command below will boot a VM in your current terminal window,
allowing you to test everything that Fedora IoT \&#96;bootc\&#96; images have to offer:

[source,bash]
----
podman-bootc run --filesystem=ext4 localhost/fedora-iot
----


= Fedora IoT Bootc Image Example with Quay

== Building and Booting a Fedora IoT Bootc Image

This example walks through building and booting a Fedora IoT \&#96;bootc\&#96; image using Quay.io, as well as pushing an update to a booted
Fedora IoT system.

NOTE: This example is based on the Fedora \&#96;bootc\&#96; documentation about building scratch images; reference the upstream docs
https://docs.fedoraproject.org/en-US/bootc/building-from-scratch/\&#35;_using_bootc_base_imagectl_build_rootfs[here] for the latest version/information.

NOTE: This example assumes the user has a Quay account with the ability to create custom repositories.

To start, create a \&#96;Containerfile.custom\&#96; with the following contents:

[source,dockerfile]
----
FROM quay.io/fedora-testing/fedora-bootc:rawhide-standard as builder
RUN /usr/libexec/bootc-base-imagectl build-rootfs --manifest=fedora-iot /target-rootfs

FROM scratch
COPY --from=builder /target-rootfs/ /
LABEL containers.bootc 1
ENV container=oci
STOPSIGNAL SIGRTMIN+3
CMD ['/sbin/init']
----

You're now ready to build a Fedora IoT \&#96;bootc\&#96; image using the custom Containerfile you made earlier. Use this command:

[source,bash]
----
podman build --cap-add=all --security-opt=label=type:container_runtime_t \
--device /dev/fuse -t localhost/fedora-iot -f Containerfile.custom .
----

Then, tag your Fedora IoT \&#96;bootc\&#96; image:

[source,bash]
----
podman tag localhost/fedora-iot:latest quay.io/[quay repository name]:fedora-iot
----

Before pushing to Quay.io, you may need to log in:

[source,bash]
----
podman login quay.io
----

Push your new Fedora IoT \&#96;bootc\&#96; image to Quay.io using the following command. Note that you may need to log in again:

[source,bash]
----
podman push quay.io/[quay repository name]:fedora-iot
----

NOTE: The next step uses \&#96;podman-bootc\&#96;. If you need to install \&#96;podman-bootc\&#96;, please follow the instructions in the
https://github.com/containers/podman-bootc[podman-bootc repository]

Now, boot your Fedora IoT \&#96;bootc\&#96; image. Open a new terminal window and run:

[source,bash]
----
podman-bootc run --filesystem=ext4 quay.io/[quay repository name]:fedora-iot
----

\&#96;podman-bootc\&#96; will pull your image and boot it inside a VM in the terminal window,
allowing you to test everything Fedora IoT \&#96;bootc\&#96; images have to offer.

== Pushing an Update to your Fedora IoT bootc system

After completing the tutorial above, you now have a functional Fedora IoT \&#96;bootc\&#96; system! But what if you need to make a change?
Updating a \&#96;bootc\&#96; system is remarkably simple -- just follow the steps below.

NOTE: This tutorial assumes you have just completed the above tutorial, and have access to a booted Fedora IoT \&#96;bootc\&#96; system.

First, navigate to your cloned Fedora Bootc Base Images repository and create a Containerfile named \&#96;Containerfile.fix\&#96; with your desired changes.

Next, rebuild your \&#96;localhost/fedora-iot\&#96; image using the new Containerfile:

[source,bash]
----
podman build --cap-add=all --security-opt=label=type:container_runtime_t \
--device /dev/fuse -t localhost/fedora-iot -f Containerfile.fix .
----

Tag your updated Fedora IoT \&#96;bootc\&#96; image:

[source,bash]
----
podman tag localhost/fedora-iot:latest quay.io/[quay repository name]:fedora-iot
----

Before pushing to Quay.io, you may need to log in:

[source,bash]
----
podman login quay.io
----

Push your updated Fedora IoT \&#96;bootc\&#96; image to Quay.io, using the command below:

[source,bash]
----
podman push quay.io/[quay repository name]:fedora-iot
----

After successfully pushing, switch back to your virtual machine running your Fedora IoT \&#96;bootc\&#96; image.
Download and queue the updated image for your next reboot:

[source,bash]
----
bootc upgrade
----

Run the following command to see your updated image staged for the next reboot:

[source,bash]
----
bootc status
----

Reboot your Fedora IoT \&#96;bootc\&#96; system and use your new updated image:

[source,bash]
----
reboot
----

After rebooting, you may need to SSH back into your Fedora IoT \&#96;bootc\&#96; system. To do so, first list all \&#96;podman-bootc\&#96; VMs:

[source,bash]
----
podman-bootc list
----

Then find the ID of your desired machine and run the following:

[source,bash]
----
podman-bootc ssh [ID]
----

After reconnecting, run check the status again:

[source,bash]
----
bootc status
----

Your updated image should now show up as \&#96;Booted\&#96;, and the previous image as \&#96;Rollback\&#96;. You have successfully updated your Fedora IoT bootc system!


= Fedora IoT Bootc Example with Raspberry Pi

Using \&#96;bootc\&#96; with Fedora IoT currently requires that you have already provisioned a device with Fedora IoT.

Follow the instructions in xref:physical-device-setup.adoc[Physical Device Setup] to provision Fedora IoT to your Raspberry Pi.

Once the Raspberry Pi is provisioned successfully, you can create a custom Fedora \&#96;bootc\&#96; image.

== Build a custom Fedora Bootc image and push it to a registry

To build your own image on your host you can create a Containerfile. This example just copies a file to \&#96;/etc\&#96;.

NOTE: this example uses the Fedora \&#96;bootc\&#96; base image and does not include all of the RPMs included as part of Fedora IoT.

[source,dockerfile]
----
FROM quay.io/fedora/fedora-bootc:latest
COPY files/secret /etc
----

To build and push the image with \&#96;podman\&#96; run the following on the host:

[source,bash]
----
podman build --platform linux/arm64 -t quay.io/username/bootc-test-image:latest
podman push quay.io/username/bootc-test-image:latest
----

This example uses https://quay.io/[Quay.io] as the registry; you may need additional configuration to push to the registry you are using.

== Switch the Raspberry Pi to your custom image

On the Raspberry Pi you can now switch to your custom image with the \&#96;bootc switch\&#96; command.

[source,bash]
----
bootc switch quay.io/username/bootc-test-image:latest
----

After rebooting the Raspberry Pi, the file copied as part of the Containerfile should be present in the filesystem:

[source,bash]
----
cat /etc/secret
----


= Contribute to Fedora IoT Edition
:url-irc: https://web.libera.chat/?channel=\&#35;fedora-iot
:url-matrix: https://matrix.to/\&#35;/\&#35;iot:fedoraproject.org
:url-matrix-meeting: https://matrix.to/\&#35;/%23meeting:fedoraproject.org

Fedora IoT is made up of many components, including a lot that are part of the main Fedora project, so there is a number of places where you may contribute.
This is by no means a canonical source for contribution, if you don't see an area where which seems to match please see the getting help section for general ways to engage with us to get answers to your questions.

If you're interested in joining the Fedora IoT Working Group, check out the xref:iot-wg::index.adoc[IoT WG docs].

== Reporting IoT bugs

If you are seeing issues with software that is included in the Fedora IoT Edition that is not necessarily specific to IoT the bug should be reported against the specific Fedora component.
There's details on how to do that in the https://docs.fedoraproject.org/en-US/quick-docs/bugzilla-file-a-bug/[how to file a bug] doc.

If you know which component the bug is in, file a bug in https://bugzilla.redhat.com[Red Hat Bugzilla] against the _Fedora_ product and the component in question.
Set the bug to block the https://bugzilla.redhat.com/show_bug.cgi?id=IoT[IoT Bugzilla tracker].

If you don't know which component to use or would to request a new package or feature be added to Fedora IoT,  you can file an issue in the https://github.com/fedora-iot/iot-distro/issues/new/choose[IoT Distro] Issue tracker in Github.

== Getting IoT help

We primarily communicate by the https://lists.fedoraproject.org/admin/lists/iot.lists.fedoraproject.org/[Fedora IoT mailing list] and the {url-irc}[\&#35;fedora-iot IRC channel on Libera.Chat] (bridged to {url-matrix}[\&#35;iot on chat.fedoraproject.org]).

== Weekly meetings

We meet every Wednesday 14:00UTC (10:00EST) in the {url-matrix-meeting}[Fedora meeting room on Matrix]. Feel free to hop in and join the discussion!


= Reference Platforms

Fedora IoT supports the aarch64 (arm64) and x86_64 architectures.

We only actively support UEFI plaforms so if your device doesn't boot with UEFI it probably won't work.

These reference platforms have been tested and are known to work with Fedora IoT, however their inclusion on this list does not necessarily constitute a release-blocking issue should a bug that is specific to the hardware below be found.

The currently tested reference devices are as follows:

== aarch64 (arm64) architecture

[cols='3\&#42;a',frame='none',grid='none',align='center']
|===
| image::ARM1605_SystemReadyStandardStamplogo_SR_V1.png[caption='',title='SystemReady-SR Server Ready (SBSA/SBBR)']
| image::ARM1605_SystemReadyStandardStamplogo_ES_V1.png[caption='',title='SystemReady-ES Embedded System Ready']
| image::ARM1605_SystemReady_logo_IR_V1.png[caption='',title='SystemReady-IR IoT Ready']

| image::tianocore-logo.svg[align='center',caption='',title='KVM based VM (TianoCore UEFI)']
| image::nvidia-jetson-agx-xavier-devkit.png[,200,200,caption='',title='NVidia Jetson Xavier Series']
| image::nvidia-jetson-agx-orin-devkit.png[,200,200,caption='',title='NVidia Jetson Orin Series']

| image::raspberry-pi4.png[,200,200,caption='',title='Raspberry Pi 4 (4B/CM4)']
| image::raspberry-pi3b.png[,200,200,caption='',title='Raspberry Pi 3 (3B/3B+/3CM)']
| image::ROCK960_Front_SD.png[,300,200,caption='',title='96boards Rock960 Consumer Edition']

| image::hummingboard-pulse.png[,200,200,caption='',title='Solid Run HummingBoard-M (i.MX8 based)']
| image::ROCKPro64-SBC-3.jpg[,190,200,caption='',title='Pine64 Rockpro64 and Rock64']
| image::PINEA64_LTS_board_front.jpg[,300,200,caption='',title='Pine64 A64-LTS and SoPine']
|===

== x86_64 architecture

[cols='3\&#42;a',frame='none',grid='none',align='center']
|===
| image::tianocore-logo.svg[align='center',caption='',title='KVM based VM (TianoCore UEFI)']
| image::fitlet2.png[,200,200,caption='',title='Compulabs Fitlet2']
| image::up_squared.png[,200,200,caption='',title='Up Squared']

| image::intel-x86.png[caption='',title='Generic Intel x86-64 products with UEFI']
|
|
|===

Other devices should work, but aren't being actively tested in the context of IoT.
The list of supported reference devices will expand with time.

== Required resources

The images being created are currently 4GB in size.
The current memory used for testing is 1GB of RAM.
The Fedora IoT base image should run with less,
but of course this limits the amount of container applications that can be run on top of the base OS.


= IoT Product Requirement Document

== Document Purpose and Overview

== What this document describes

This is the http://en.wikipedia.org/wiki/Product_requirements_document[Product Requirements Document] for Fedora IoT. It:

\&#42; Provides a high-level market overview of the IoT market as it pertains to Fedora IoT; this includes items which may not be within our actual scope/ability to accomplish at the current time.
\&#42; Provides deeper understanding of the types of users who could use Fedora for their IoT needs. This includes describing their main day-to-day tasks, common problems, etc. The perspective here is not necessarily limited to system administrators, or developers, but a combination of many types of users and roles.
\&#42; Ties common issues and needs of potential users/consumers of Fedora IoT to high-level product needs, from a 'functional' standpoint.

This document does not dictate implementation details. The goals in this document will drive the continued implementation of this Edition.

=== Fedora IoT Vision Statement

Fedora is the default platform in the IoT space. Anyone starting an IoT project, from cute embedded hacks all the way up to a multi-million device deployment will start with Fedora.

=== Fedora IoT Mission Statement

Fedora IoT makes Fedora the default for open source innovation on IoT hardware, endpoint, edge, middleware, cloud, and backend platforms.

== Market Opportunity

The IoT market is relatively immature and rapidly expanding. https://www.forbes.com/sites/louiscolumbus/2017/12/10/2017-roundup-of-internet-of-things-forecasts/\&#35;5af4bc1b1480[Analysts predict] the global market will grow to $457B in 2020, representing an annualized growth rate of nearly 30%. Fedora IoT has opportunity for adoption as the market expands to in number and innovation.

IoT uses span from trivial toy projects to home automation to industrial control to autonomous driving. IoT devices present several challenges compared to general-purpose computing:

\&#42; Resource-constrained devices
\&#42; Security risks due to default passwords and short maintenance lifecycles
\&#42; Data management and AI requirements at the edge

== Edition Objectives

=== Primary Objective

The initial Fedora IoT Objective consists of a base edition released on a regular monthly cycle that can be used for running IoT devices:

\&#42; Endpoint
\&#42; Edge
\&#42; Middleware
\&#42; Gateway
\&#42; Network, storage and other appliances

The base edition will support multiple architectures, initially including x86_64, aarch64 and ARMv7, and include the ability to produce supported containers across all architectures for various IoT use-cases and verticals. These containers will be capable of running on the Fedora IoT base edition, and subsequently also running on Kubernetes platforms such as OpenShift to provide end to end IoT platforms.

Demos for a number of use cases will be provided including orchestration to deploy demos, container recipe example to create IoT application stacks to run on Fedora IoT.

Future plans for the IoT Objective include complex End to end IoT use cases including end points, messaging, data lakes and analysis, including appropriate orchestration.

=== Secondary Objectives

Aside from the adoption and development of applications on top of the Fedora IoT platform, we have a few secondary goals that should be helped by wider adoption:

\&#42; Encourage engagement in the Fedora ecosystem from the wider IoT audience, including hardware vendors, other open source projects, hobbyists, and students
\&#42; Positive press coverage from general media and IoT-specific media
\&#42; Improvements to projects and technologies used by the Fedora IoT objective that can benefit the upstream projects and Fedora as a whole

== User Profiles, Primary Use Cases and Goals
=== Personas

We will use a set of personas to describe our target users and their respective needs. This document will list the personas in their simplified forms, with detailed explanations of each one available on their respective wiki pages.

\&#42; IoT hobbyist and systems administrator
\&#42;\&#42; Uses IoT devices to experiment with technology. This could be a home user using platforms such as Mozilla Web of Things Gateway or Home Assistant to do home automation or a systems administrator experimenting with IoT technologies.
\&#42; Makers and hobbyists
\&#42;\&#42; Uses SBCs such as the Raspberry Pi to experiment with robotics, control of devices or to retrofit and improve other technologies.
\&#42; Partners
\&#42;\&#42; Companies that wish to support Fedora IoT on their devices to provide options for their customers when building IoT platforms and products
\&#42; Companies
\&#42;\&#42; Companies that wish to use Fedora IoT as a basis for their IoT product or platform
\&#42; Security and Data Protection
\&#42;\&#42; Security and data protection officers.
\&#42;\&#42; End to end traceability and demonstrable security at every level
\&#42;\&#42; Security researchers

=== Use Cases

There's a lot of possible use-cases that Fedora IoT will need to address. IoT is a vast array of verticals and it's impossible to address all of them with a small community. The aim for Fedora IoT is to provide a good and generic base for which to build any IoT platform.
Fedora IoT will need to address the following use-cases:

\&#42; Base platform
\&#42;\&#42; Extremely thin profile
\&#42;\&#42; Use CoreOS/ostree technologies to provide thin update deltas with roll back capability to provide as close to a non brickable platform as possible.
\&#42;\&#42; Uses the latest linux technologies to tighten the security as possible
\&#42;\&#42; Provides low resource industry standard container platform
\&#42;\&#42; Supports a wide variety of hardware including reference platforms, wired and wireless interfaces, and other hardware interfaces such as FPGA and cameras
\&#42;\&#42; pluggable system to detect success/failure of upgrades and to role back to ensure system is always working
\&#42; Home gateway
\&#42;\&#42; Mozilla Web of Things Gateway
\&#42;\&#42; Home assistant
\&#42; Industrial Gateway
\&#42;\&#42; Numerous options available.
\&#42;\&#42; EdgeX
\&#42;\&#42; OPC UA open62541
\&#42; Data storage and representation
\&#42;\&#42; Open Source data lake for IoT ingestion
\&#42;\&#42; Open alternatives to some of the cloud providers
\&#42;\&#42; Messaging support such as MQTT and AMQP
\&#42;\&#42; Data analytics

=== Core services and features

\&#42; Greenboot

=== Core applications

None

=== Unique policies for installation, updates, etc

None

== Logistical Concerns

=== Delivery Mechanisms

Fedora IoT will produce a rolling release with monthly snapshots using Fedora Core OS. The working group will coordinate with Fedora Release Engineering to ensure monthly snapshots are produced and distributed in a supportable manner.

=== Documentation

The IoT working group will work with the Documentation team to produce IoT-specific documentation for users and developers.

==== Where to obtain
Users will be able to obtain these images from the Fedora Project website and mirror networks.

=== Measuring Success

In order to measure success we will monitor (somewhat arbitrary) numbers over time. The list of metrics we take in account will be adapted over time to measure specific efforts within the framework of the Server Working Group goals.

The initial basic set of metrics will be:

\&#42; At least one large hardware vendor uses Fedora IoT as the basis for their platform.

=== Scope of hardware support

See xref:../reference-platforms.adoc[Reference Platforms].

=== Release deliverables

|====
| \&#42;\&#42;Deliverable\&#42;\&#42; | \&#42;\&#42;Release blocking\&#42;\&#42; | \&#42;\&#42;Optical boot is blocking\&#42;\&#42; | \&#42;\&#42;Max size\&#42;\&#42;
|IoT/aarch64/images/Fedora-IoT-_RELEASE_MILESTONE_.aarch64.raw.xz | yes | no | N/A
|IoT/aarch64/iso/Fedora-IoT-IoT-ostree-aarch64-_RELEASE_MILESTONE_.iso | yes | no | N/A
|IoT/armhfp/iso/Fedora-IoT-IoT-ostree-armhfp-_RELEASE_MILESTONE_.iso | no | no | N/A
|IoT/x86_64/images/Fedora-IoT-_RELEASE_MILESTONE_.x86_64.raw.xz | yes | no | N/A
|IoT/x86_64/iso/Fedora-IoT-IoT-ostree-x86_64-_RELEASE_MILESTONE_.iso | yes | no | N/A
|====

== About this Document

=== Authors
Contributors to this document include:

\&#42; bcotton
\&#42; mattdm
\&#42; pbrobinson



= Fedora IoT Working Group

This page documents the Standard Operating Procedures for the IoT working group in Fedora.

== Standard Operating Procedures

\&#42; xref:sop-branching-fedora-iot.adoc[Branching Fedora IoT]
\&#42; xref:iot-weekly-meetings-sop.adoc[Attending/Running IoT WG Weekly Meetings]


= Branching Fedora IoT

Branched is the name given to a version of Fedora that has 'branched' from the rolling Rawhide tree and will become the next stable Fedora release. This document will detail the steps for branching Fedora IoT from Rawhide.

To complete these steps and open any pull requests you need a valid https://docs.fedoraproject.org/en-US/fedora-accounts/user/[Fedora account].

== Working with the pungi-iot repository

Clone and fork the Fedora IoT Pungi repository to make changes to the configuration files used to build Fedora IoT.

----
git clone https://pagure.io/fedora-iot/pungi-iot.git
----


Create the new branch and push to the upstream repository. Change \&#96;$release\&#96; to the new numeric branch of Fedora.
This is not done as a PR and should be pushed directly to the upstream repository, to do so you will need commit permissions.

----
git checkout main; git pull; git checkout -b f$release; git push --set-upstream upstream f$release
----

Example, used for Fedora 40:

----
git checkout main; git pull; git checkout -b f40 ; git push --set-upstream upstream f40
----

=== Rawhide (main)

On your local fork, create a new branch for changes to Rawhide (main).

Update the signing key for Rawhide from the main https://pagure.io/pungi-fedora/commits/main[Fedora Pungi repo].
As of Fedora 40 branching you can find this https://pagure.io/pungi-fedora/blob/main/f/fedora.conf\&#35;_21[here].

Copy the key used in Rawhide to \&#96;fedora-iot.conf\&#96;, replacing the previous key.

Example:

----
sed -i 's|$OLD_SIGNING_KEY|$NEW_RAWHIDE_KEY|g' fedora-iot.conf
----

Example used in Fedora 40 branching:

----
sed -i 's|a15B79cc|e99d6ad1]|g' fedora-iot.conf
----

Main will remain as 'Rawhide', but we need to update the release to the next version of Fedora.

----
sed -i 's|40|41|g' fedora-iot.conf nightly.sh sync-release.sh twoweek-nightly.sh
----

Commit the changes:

----
git commit -a -m 'F-41: Update for branching' -s
----

Review the changes and if satisfied, push to your fork and open a pull request for others to review. https://pagure.io/fedora-iot/pungi-iot/c/db00b44a9ddf0eb37c4194b089bbea799cb3ecb6?branch=main[Example PR]

=== Branched (the next stable fedora release)
Now we need to work on the new release, or branch of Fedora that we created at the beginning, and specify the release number (eg '40') rather than 'Rawhide'.

Example:

----
git checkout f$release
----

Used in Fedora 40 branching:

----
git checkout f40
----

On your local fork, create a new branch for changes.

Update symlinks to ensure we are using the latest completed upstream compose in Fedora

----
sed -i 's|latest-Fedora-Rawhide|latest-Fedora-40|g' fedora-iot.conf
----

Update Fedora URLS with 'branched':

----
sed -i 's|compose/rawhide|compose/branched|g' fedora-iot.conf
----

Update iot repos to use 'devel' rather than 'rawhide':

----
sed -i 's|fedora/rawhide/|fedora/devel/|g' fedora-iot.conf
----

Update instances of 'main' to the release:

----
sed -i 's|main|f40|g' fedora-iot.conf
----
IMPORTANT: You will need to manually change the comps and bootc \&#96;base-images\&#96; repos back to main. There are no branches in comps or \&#96;base-images\&#96;. (comps files are XML files used by various Fedora tools to perform grouping of packages into functional groups. For more information visit https://pagure.io/fedora-comps[click here].

Update the 'global_ksurl':

----
sed -i 's|=HEAD|=origin/f40|g' fedora-iot.conf
----

Update the location of where the release is copied to during the compose process, and hosted for download and rsync'ing to the various Fedora mirrors. This path is created when the \&#96;twoweek-nightly.sh\&#96; is executed and can be found on the https://dl.fedoraproject.org/pub/alt/iot/[Fedora Project master mirror].
----
sed -i 's|/pub/alt/iot/rawhide/|/pub/alt/iot/branched/|g' twoweek-nightly.sh
----

Commit the changes:

----
git commit -a -m 'F-40: Update for branching' -s
----

Review the changes and if satisfied, push to your fork and open a pull request for others to review. https://pagure.io/fedora-iot/pungi-iot/c/8793fd5b80e3c269bac84cda175f5bf9987eea99?branch=f40[Example PR]

== Working with the OStree repository

This repository is used to configure the Fedora IoT ostree and includes the packages, services and various settings including selinux and unified-core.

Clone and fork the upstream ostree repository:

----
git clone https://pagure.io/fedora-iot/ostree.git
----

Create the new branch and push to the upstream repository. Change \&#96;$release\&#96; to the new numeric branch of Fedora:

----
git checkout main; git pull; git checkout -b f$release; git push --set-upstream upstream f$release
----

Example, used for Fedora 40 (the next stable release of Fedora):

----
git checkout main; git pull; git checkout -b f40 ; git push --set-upstream upstream f40
----

=== Rawhide (main)
Create a branch in your local fork and make the following changes for Rawhide:

----
sed -i 's|40|41|g' config.ini fedora-40.repo fedora-iot-base.yaml fedora-iot.yaml
mv fedora-40.repo fedora-41.repo
git add fedora-41.repo
git commit -a -m 'IoT: Update rawhide for F-41' -s
----

Review the changes and if satisfied, push to your fork and open a pull request for others to review.

=== Branched (the next stable fedora release)
Checkout the newly created branch for the next stable Fedora and create a branch in your fork for the PR.

Change the urls from \&#96;development/rawhide\&#96; to \&#96;development/40\&#96;:

----
sed -i 's|development/rawhide|development/40|g' config.ini
----

Update instances of \&#96;rawhide\&#96;, replacing with \&#96;devel\&#96;:

----
sed -i 's|rawhide|devel|g' config.ini fedora-40.repo fedora-iot-base.yaml fedora-iot.yaml fedora-iot-updates-stable.yaml fedora-iot-updates-testing.yaml
----

Write the commit message:

----
git commit -a -m 'Setup for F-40 branched' -s
----

Review the changes and if satisfied, push to your fork and open a pull request for others to review.

== Additional Checks
\&#42; check to make sure the Fedora IoT tag has been created in koji. To verify you will need to install the \&#96;koji\&#96; package in Fedora
\&#42;\&#42; Verify the tags are listed for the new branches \&#96;koji list-tags|grep f\&#42;-iot\&#96;

\&#42; ensure the signing key has been updated in Ansible (look for the iot portion)
\&#42;\&#42; https://pagure.io/fedora-infra/ansible
\&#42;\&#42; As of Fedora 40 you can find the relevant section https://pagure.io/fedora-infra/ansible/blob/main/f/roles/robosignatory/templates/robosignatory.toml.j2=_434[here].
\&#42; Make sure to update Ansible and create a cron job for the development (devel) release. You can find cron jobs https://pagure.io/fedora-infra/ansible/blob/main/f/roles/releng/files[here].
\&#42; Create a treefile in the \&#96;base-images\&#96; and \&#96;fedora-iot-bootc\&#96; repositories pointing to the newly branched release. This may be obsolete with the move to Konflux. An example of the treefile used for Fedora 41 composes can be found https://gitlab.com/fedora/bootc/base-images/-/blob/main/fedora-41.yaml?ref_type=heads[here]. Branched composes use \&#96;fedora-devel\&#96;.

You will need to create the file as it gets removed at Final. Example for \&#96;devel-iot\&#96; (IMPORTANT - Make sure to update the branched used, in the example it's \&#96;f41\&#96;):

----
\&#35; IoT devel compose
MAILTO=releng-cron@lists.fedoraproject.org
00 14 \&#42; \&#42; \&#42; root touch /tmp/fedora-compose-devel-iot \&amp;\&amp; TMPDIR=\&#96;mktemp -d /tmp/devel.XXXXXX\&#96; \&amp;\&amp; cd $TMPDIR \&amp;\&amp; git clone https://pagure.io/fedora-iot/pungi-iot.git \&amp;\&amp; cd pungi-iot \&amp;\&amp; git checkout f41 \&amp;\&amp; ./twoweek-nightly.sh RC-$(date '+\%Y\%m\%d').0 \&amp;\&amp; rm /tmp/fedora-compose-devel-iot
----

Add it to the IoT section of main.yml found https://pagure.io/fedora-infra/ansible/blob/main/f/roles/releng/tasks/main.yml[here]:

----
\&#35; put cron job in for IoT devel compose
- name: IoT devel compose cron
ansible.builtin.copy:
src: devel-iot
dest: /etc/cron.d/devel-iot
mode: '644'
when: inventory_hostname.startswith('compose-iot01.iad2')
----


= Create Fedora IoT Release Candidates

To complete these steps you will need a valid https://docs.fedoraproject.org/en-US/fedora-accounts/user/[Fedora account], with appropriate permissions in https://koji.fedoraproject.org/koji/[Koji], the Fedora buildsystem.

Review the current compose tag used for Fedora IoT and what is currently tagged and included.

----
koji list-tagged f[release_version]-iot
----

Untag any builds currently included:

----
koji untag-build --all f[release_version]-iot [build1 build2 \&#8230;]
----

Review the upstream Fedora ticket requesting the Release Candidates for a listing of all Fedora release Blockers and Freeze Exceptions that are needed for the compose.
\&#42; An example ticket for https://pagure.io/releng/issue/12007[Fedora 40 Beta Candidate Request].
\&#42; An example ticket for https://pagure.io/releng/issue/12060[Fedora 40 Final Candidate Request].

Add any builds specified by the Fedora QE team.

----
koji tag-build f[release_version]-iot [build1 build2 \&#8230;]
----

Compare the tagged builds with the Fedora compose tag (f40-compose):

----
koji list-tagged f[release_version]-compose
----

Log into the Fedora IoT compose host and run the compose for the pending release. Once the compose is complete, review the results for any outstanding deliverables.

== Once the release has been declared \&#96;Go!\&#96;

=== Beta

When the release is signed off on Thursday after the Go/No-Go meeting. Open a ticket with https://pagure.io/releng/issues[Release Engineering] to sign the deliverables. A request https://pagure.io/releng/issue/11677[example] from Fedora 39.

Once the release is signed, from the compose host create the directory and run the script to copy the release so it can be sync'd to the Fedora mirrors.

For the Beta release, note the destintation is the \&#96;test\&#96; directory:

----
mkdir /pub/alt/iot/test/[release_version]
./sync-release.sh
----

=== Final

The final release requires an additional compose moving the \&#96;development\&#96; release to \&#96;stable\&#96;.

==== Update the signing key

Open a pull request to update the signing key for the specified release. Example from https://pagure.io/fedora-infra/ansible/pull-request/2325[Fedora 41 GA].

==== Update Pungi configuration

Create a local fork of the Fedora https://pagure.io/fedora-iot/pungi-iot.git[IoT Pungi repository] to make changes to the configuration files used to build Fedora IoT.

Update the the URL used for the compose, moving from \&#96;latest\&#96; to the compose declared Gold in the Go/NoGo meeting. This example uses the Fedora 41 GA compose:

----
sed -i 's|branched/latest-Fedora-41/|41/Fedora-41-20241024.0/|g' fedora-iot.conf
----

Next update the branch from \&#96;devel\&#96; to \&#96;stable\&#96;:

----
sed -i 's|fedora/devel/|fedora/stable/|g' fedora-iot.conf
----

Update the \&#96;sync-bootc-base-containers.sh\&#96; script, moving the development release to stable.

----
sed -i 's|current_stable='40'|current_stable='41'|g' sync-bootc-base-containers.sh
sed -i 's|current_devel='41'|\&#35;current_devel='41'|g' sync-bootc-base-containers.sh
----

Review changes and open a pull request for peer review.

==== Update the ostree repository

Update the https://pagure.io/fedora-iot/pungi-iot.git[Fedora IoT ostree repository] for the final compose. Update the branch from \&#96;devel\&#96; to \&#96;stable\&#96; and the release URL from branched to the release directory. The examples below were used for Fedora 41 GA.

----
sed -i 's|s/devel/%(arch)s/|s/stable/%(arch)s/|g' config.ini
sed -i 's|fedora/devel/|fedora/stable/|g' \&#42;.yaml
sed -i 's|fedora/linux/development/41|fedora/linux/releases/41|g' config.ini
----

Review changes and open a pull request for peer review.

==== Update Automated compose

Ensure the cron job used to automate the compose for \&#96;stable-iot\&#96; is updated to point to the correct https://pagure.io/fedora-infra/ansible/blob/main/f/roles/releng/files/stable-iot[branch] for the new stable release and delete the cronjob used for the development release, \&#96;devel-iot\&#96;.

==== Release compose

After the changes have been merged, complete the GA compose. Once completed, open a ticket with https://pagure.io/releng/issues[Release Engineering] to sign the deliverables. A request https://pagure.io/releng/issue/11677[example] from Fedora 39.

==== Sync the Release

Once the release is signed, from the compose host create the directory and run the script to copy the release so it can be sync'd to the Fedora mirrors.

----
mkdir /pub/alt/iot/[release_version]
./sync-release.sh
----
